# Сервер авторизации

- [Вход в систему](#вход-в-систему)
- [Авторизация](#авторизация)
- [Запрос стороннего приложения](#запрос-стороннего-приложения)

### Вход в систему

Сам процесс входа в систему описан в разделе ниже.

В процессе входа в систему пользователю назначается токен доступа. Этот токен позволяет проходить повторную аутентификацию в упрощенном режиме.

Есть несколько вариантов работы с токеном доступа.

1. Первый кейс

Пользователю выдается пара токенов:

- токен доступа короткого срока действия,
- токен обновления длительного срока действия или бесконечный.

По истечению срока действия токена доступа, клиентское приложение должно запросить у сервера авторизации новый токен доступа, предоставив токен обновления.

В таком варианте выход из приложения в привычном смысле невозможен. Потому что пользователь будет в системе пока не закончится срок действия токена обновления.

2. Второй кейс

Пользователю выдается только один токен доступа с бесконечным сроком.

При этом, этот токен записывается в базу данных для этого пользователя.

Проверка токена и идентификация пользователя происходит путем проверки существования токена в базе данных.

Если этот токен очистить, соответственно, произойдет выход пользователя из системы.

[^ к оглавлению](#оглавление)

### Авторизация

Вы открываете клиентское приложение.

Клиентское приложение отправляет запрос на сервер авторизации.

В самом начале сервер авторизации проверяет, зарегистрировано ли указанное клиентское приложение, от которого поступил запрос. Для идентификации клиентского приложения, сервер проверяет полученные данные:

    client_id
    client_secret

[Спецификация RFC6749 2.3](https://datatracker.ietf.org/doc/html/rfc6749.html#section-2.3)

Здесь может быть два варианта:

- клиент не зарегистрирован, либо данные неверны,
- клиент зарегистрирован и данные верны.

1. Клиент не зарегистрирован, либо данные неверны

Сервер возвращает ошибку.

Дальше нет никаких действий.

2. Клиент зарегистрирован и данные верны

Сервер возвращает ответ без ошибки. Это значит, что он готов принимать данные пользователя.

Клиентское приложение отправляет данные.

Сервер авторизации запускает механизм аутентификации пользователя по представленным данным. Например, это может быть наличие токена в заголовке запроса.

Здесь может быть два варианта:

- пользователь не аутентифицирован,
- пользователь аутентифицирован.

2.1. Пользователь не аутентифицирован

Если пользователь не аутентифицирован, сервер авторизации возвращает ответ с предоставлением uri на страницу с формой входа.

Клиентское приложение открывает эту страницу и пользователь действует одним из следующих путей:

- вводит свои учетные данные для входа,
- регистрируется,
- запрашивает вход через сторонний сервис.

2.1.1. Пользователь вводит свои учетные данные для входа

Как правило, это логин и пароль.

Сервер авторизации проверяет наличие учетной записи по этим данным.

Здесь также может быть два варианта:

- учетной записи нет, либо данные не верны,
- учетная запись есть и данные верны.

2.1.1.1. Учетной записи нет, либо данные не верны

Сервер возвращает ошибку на свою же страницу с формой входа.

Пользователь может попробовать аутентифицироваться заново или выбрать другой путь из п.2.1.

2.1.1.2. Учетная запись есть и данные верны

Сервер аутентифицирует пользователя и приступает к процедуре авторизации (п.2.2).

2.1.2. Пользователь регистрируется

Сервер авторизации предоставляет форму регистрации.

После ввода всех данных, сервер создает новую учетную запись.

Для упрощенной регистрации этого может быть достаточно. Для повышения защиты могут использоваться дополнительные механизмы проверки.

Например, учетная запись пользователя будет неактивной, пока он не подтвердит свой email. Для этого сервер генерирует уникальный ключ активации, либо привязывает ключ к идентификатору (например, логину) пользователя. После регистрации, сервер отправляет пользователю письмо со ссылкой на эндпоинт api и с передачей ключа активации и, если необходимо, идентификатору пользователя. Этот эндпоинт запускает скрипт, который просто находит пользователя, проверяет ключ и активирует учетную запись.

Вместо email может быть задействован номер телефона, а ключ отправляться по СМС.

Можно сделать подобный механизм на этапе до регистрации пользователя, таким образом упростив процесс со стороны пользователя.

После того, как пользователь зарегистрирован, сервер выполняет действия из п.2.1.1.2.

2.1.3. Пользователь запрашивает вход через сторонний сервис

Например, сторонним сервисом может быть google, vk, яндекс, mail.ru и др. сервисы, поддерживающие OAuth 2.0/

Тогда сервер запускает процесс обращения к стороннему сервису, который неявно воспроизводит шаги 2.1.1 - 2.1.2.

В результате сервер получает подтвержденные (почти гарантированно) учетные данные пользователя.

Если эти учетные данные есть в его системе, он аутентифицирует пользователя (п.2.1.1.2).

Если учетных данных нет, но может автоматически зарегистрировать этого пользователя и также аутентифицировать его (п.2.1.1.2).

2.2. Пользователь аутентифицирован

Сервер переходит к процессу авторизации, т.е. выдачи прав.

Для прав используется множество механизмов. Например, CRUD в базе данных, группировка по разным уровням доступа. Но все это должно касаться только клиентского приложения и сторонних приложений.

Ответственность сервера авторизации состоит в простом определении, есть ли у пользователя права доступа к тому или иному сервису.

За это отвечают области доступа.

[Спецификация RFC6749 1.3.4](https://datatracker.ietf.org/doc/html/rfc6749.html#section-1.3.4)

В данной реализации области доступа определяют, разрешено ли данному пользователю использование клиента. Причем в данном случае клиентом может быть как само клиентское приложение, так и сторонние приложения. Нужно лишь, чтобы они были зарегистрированы в системе в качестве клиентов.

Здесь может быть два варианта:

- пользователь не авторизован,
- пользователь авторизован.

2.2.1. Пользователь не авторизован

Значит, доступ к клиенту для пользователя запрещен. Сервер возвращает клиенту ошибку.

Дальше действий нет.

2.2.2. Пользователь авторизован

Пользователю разрешен доступ к клиенту. Сервер возвращает ответ, в котором содержатся данные пользователя.

Сервер также может перейти по зарегистрированному для клиента uri редиректа и передать данные в этом uri.

[Спецификация RFC6749 3.1.2](https://datatracker.ietf.org/doc/html/rfc6749.html#section-3.1.2)

Клиент сам будет работать с этими данными.

У сервера авторизации дальше действий нет.

[^ к оглавлению](#оглавление)

### Запрос стороннего приложения

Для начала определим следующее:

- наш пользователь уже авторизован в клиентском приложении,
- стороннее приложение также зарегистрировано в качестве клиента на нашем сервере авторизации,
- наш пользователь имет доступ к стороннему приложению через область доступа.

Теперь разберем несколько кейсов.

1. Первый кейс

Предположим, нам нужно войти в стороннее приложение без ввода пароля.

В этом случае мы просто должны в запросе к стороннему приложению передать свой токен.

Стороннее приложение повторит действия из п.2, п.2.2, п.2.2.2 раздела "Последовательность действий. Авторизация".

2. Второй кейс

Возьмем другую ситуацию. Нам нужно получить данные нашего же пользователя, но из стороннего приложения. Сами мы находимся в клиентском приложении.

Проще всего это сделать через обращение к эндпоинту api стороннего приложения. Этот эндпоинт будет скорее всего защищен от неавторизованных запросов и будет выдавать информацию только для конкретного пользователя.

В этом случае мы также делаем запрос к стороннему приложению и передаем свой токен.

Стороннее приложение повторит действия из п.2, п.2.2, п.2.2.2 раздела "Последовательность действий. Авторизация".

Затем выдаст ответ с данными пользователя. Клиентское приложение принимает эти данные и дальше работает с ними.

3. Третий кейс

Теперь возьмем ситуацию, когда мы обращаемся к стороннему приложению из клиентского приложения для выполнения каких-то действий от нашего имени.

Например, поделиться интересной ссылкой со всеми друзьями.

По-сути, этот тот же кейс, что и предыдущий. Проще всего это реализовать через api стороннего приложения.

В таком виде запросы будут выполняться от имени пользователя. Но для безопасности, мы должны разрешить подобные действия между приложениями. Для этого мы должны в стороннем приложении:

- подготовить эндпоинты только для приложений,
- добавить авторизацию запросов от других приложений,
- разрешать/запрещать выполнение действий другими приложениями от лица пользователя,
- разрешать/запрещать передачу данных другим приложениями от лица пользователя.

На сервере авторизации в такие запросы потребуется добавлять идентификатор клиентского приложения и другие данные, например, название приложения, описание, логотип, ссылку и т.д.

4. Четвертый кейс

Мы обращаемся к серверу авторизации из клиентского приложения, чтобы авторизовать пользователя. Если пользователь авторизован, то все ок. Мы можем выдать ему внутренний токен или другим каким-то образом связать его с нашей базой пользователей.

5. Пятый кейс

Мы обращаемся к серверу авторизации из клиентского приложения, чтобы авторизовать пользователя по протоколу OAuth 2.0, как к любому стороннему сервису авторизации.






Обязательно передавать этот запрос с заголовком токена авторизации пользователя. Клиент привязывается к пользователю и авторизация в этом случае обязательна.

Response

{
	"id": "27",
	"createdAt": "2024-02-27T22:33:15.647Z",
	"updatedAt": "2024-02-27T22:33:15.647Z",
	"title": "string",
	"description": "string",
	"client_uri": "string",
	"redirect_uri": "string",
	"publishedAt": "2024-02-27T22:33:15.647Z",
	"isPublished": true,
	"client_id": "887059dd-2814-43b4-81ac-d2bc21cc564f",
	"client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
}

Для валидности всех остальных запросов, ключ client_secret должен передаваться в любом из следующих двух способов.

1. В заголовке client_secret:

    client_secret: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM

2. В теле POST-запроса:

    {
        "client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
    }

Мы исключили способ передачи client_secret как Bearer-токена в заголовке authorization из-за возможных конфликтов. Ключ client_secret будет передаваться совместно с токеном пользователя. А тот, в свою очередь, будет использовать Bearer как основной способ передачи. 

## Проверка клиентского приложения

/clients/self

GET/POST

Response

{
	"id": "27",
	"createdAt": "2024-02-27T22:33:15.647Z",
	"updatedAt": "2024-02-27T22:33:15.647Z",
	"title": "string",
	"description": "string",
	"client_uri": "string",
	"redirect_uri": "string",
	"publishedAt": "2024-02-27T22:33:15.647Z",
	"isPublished": true,
	"client_id": "887059dd-2814-43b4-81ac-d2bc21cc564f",
	"client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
}

## Регистрация пользователя

/auth/register

POST

{
    username: string,
    password: string,
}

Response

{
	"id": "5",
	"createdAt": "2024-02-27T22:56:59.240Z",
	"updatedAt": "2024-02-27T22:56:59.240Z",
	"username": "test@test.ru",
	"password": "$2a$10$WcAa9r9C7njigob6GIgS3ejiyHE8WZsx6BY47g6digiVv9QeIjPtq",
	"passportStrategy": null,
	"passportId": null,
	"isActivated": false,
	"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M",
	"refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcxMTY2NjYxOX0.qLAR4f-yD3smdfXp0XhJSl5hmEULdVh8kOQxUHFGFTQ"
}

Был задан пароль:

    123456

Для валидности всех остальных запросов, ключ access_token должен передаваться в как Bearer-токен в заголовке authorization:

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M


## Проверка запроса в другое клиентское приложение

http://localhost:5000/posts/get_all

POST

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M
    client_secret: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM

Что здесь должно быть:

- другое клиентское приложение развернуто на localhost:3001

- в другом клиентском приложении должен быть эндпоинт restapi /posts/get_all с выводом всех постов

- эндпоинт должен быть защищен от неавторизованных пользователей (например, тот же декоратор @Auth)

- другое клиентское приложение для аутентификации и проверки пользователей должно обращаться к серверу авторизации

- другое клиентское приложение может проксировать поступивший authorization на сервер авторизации

- другое клиентское приложение может проксировать поступивший client_secret на сервер авторизации

- сервер авторизации должен проверять
    * проксированный client_secret
    * client_secret другого клиентского приложения
на разрешение доступа к другому клиентскому приложению по scope

## Наша работа

1. пользователь вошел в наше клиентское приложение

2. клиентское приложение пытается узнать пользователя, скорее всего по токену, который хранит в локалсторе

2.1. клиентское приложение не узнало пользователя

2.1. пользователь не видит личный кабинет, зато видит кнопку "войти" и нажимает ее

2.1.1. клиентское приложение запрашивает сервер авторизации на выдачу токена с обратным редиректом

2.1.2. сервер авторизации показывает форму входа

2.1.3. пользователь вводит свои данные

2.1.4. сервер авторизации авторизует пользователя

2.1.5. сервер авторизации отправляет пару токенов по обратному редиректу

2.1.6. клиентское приложение получает токены пользователя

2.1.7. клиентское приложение запрашивает информацию о пользователе с помощью этих токенов

2.1.8. сервер авторизации возвращает клиентскому приложению информацию о пользователе

2.1.9. клиентское приложение теперь авторизует пользователя

2.1.10. клиентское приложение выдает пользователю токен, который помещает в локалстору

2.2. клиентское приложение узнало пользователя, но его токен доступа просрочен

2.2.1. пользователь предоставляет токен обновления из локалсторы

2.2.2. клиентское приложение запрашивает сервер авторизации на обновление

 предоставляет токен обновления

2.3. клиентское приложение узнало пользователя, и его токен в порядке

2.3.1. все ок, действий нет

