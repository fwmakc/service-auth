# Схема работы

## Исходные данные

Есть пользователь, например, вы.

Есть агент или ваш веб-браузер.

Есть клиент или клиентское приложение, под которым вы работаете.

Есть сервер авторизации.

Есть стороннее приложение, к которому вы хотите получить доступ без ввода пароля. И потом это приложение сможет обмениваться данными с клиентским приложением.

Есть сторонний сервис авторизации, на котором также есть ваша учетная запись, через которую вы хотите зарегистрироваться на сервере авторизации и в клиентском приложении.

## Процессы сервера авторизации

Идентификация - это проверка существования для вас пользовательского аккаунта в системе. Например, через id, логин или токена доступа.

Аутентификация - это проверка подлинности пользователя, что вы - это действительно этот пользователь, а не какой-то другой. Например, с помощью ввода пароля, пин-кода, использования биометрических данных или передачи токена доступа.

Авторизация - это выдача прав, доступных конкретному пользователю. Например, доступ к просмотру и отправке электронных писем, но отсутствие разрешения на создание новых почтовых ящиков.

Аутентификация невозможна без идентификации. А аутентификацию нельзя исключать из процесса по соображениям безопасности.

Тажке стоит понимать, что авторизация возможна без идентификации и аутентификации. Например, система может разрешить любому неопознанному пользователю доступ к просмотру документов. И несмотря на то, что пользователь может быть совершенно неопознанный и даже без аккаунта в системе, система все же его авторизовала - то есть выдала право прочитать этот документ.

## Последовательность действий. По спецификации

Пользователь открывает клиентское приложение.

Клиентское приложение не знает пользователя. Поэтому его нужно идентифицировать. Но вместо того, чтобы заниматься этим самому, клиентское приложение отправляет пользователя на сервер авторизации.

Вернее это выглядит так. Клиентское приложение отправляет запрос на сервер авторизации, предоставляя ему свой токен

    client_secret

Сервер авторизации видит токен и проверяет его. Аутентифицирует клиентское приложение и авторизует запрос. В результате запроса возвращается

    url

который ведет на страницу авторизации пользователя.

Либо сервер авторизации просто выводит эту страницу самостоятельно. Т.к. все эти шаги происходят в агенте пользователя (например, в браузере), то страницу можно вывести без проблем.

Пользователь вводит свои данные - логин и пароль.

(
    Как происходит запрос токенов, например в google или leaderid??? когда мы не логинимся, а сервер авторизации сразу авторизует нас
    
    Либо сервер авторизации читает токен, который есть у пользователя. Например, пользователь заходил в систему ранее.
)

И сервер авторизации авторизует пользователя. Затем он берет из бд, из записи с настройками клиента поле

    redirect_uri

и запрашивает в этом же окне указанный урл, передавая в параметрах

    код авторизации

Чем это все хорошо? Тем, что клиентское приложение ничего не знает о логине и пароле пользователя. Все это происходит вне его работы, здесь есть только пользователь и сервер авторизации.

Дальше клиент, пользуясь кодом авторизации, запрашивает у сервера авторизации токен доступа. Это также происходит в закрытом от пользователя потоке.

Т.е. по сути, код авторизации это некий код, который клиент обменивает у сервера на токен доступа. И вроде бы как это должно создавать безопасность. Давайте разберемся, как.

Во-первых, это происходит на бэке. Во-вторых, передача кода авторизации инициируется не клиентом, а сервером авторизации. Т.е. он отправляет запрос по указанному

    redirect_uri

а это значит, что код не будет выведен просто в окошке и его нельзя будет просто перехватить.

В чем ответственность клиента? Он посылает ответный запрос на сервер авторизации.

Таким образом, если злоумышленник инициирует запрос на эндпоин клиента и передаст некий набор символов, клиент пошлет этот набор на сервер авторизации, который отклонит запрос. И подделки тоже не будет.

Правда я не вижу здесь никакой надежной защиты. Например, пользователь или злоумышленник может перехватить этот код авторизации, встав на трафик. И отправить его на эндпоинт сервера авторизации, чтобы обменять на токен доступа. В результате мы получим тот же токен доступа.

Токен доступа мы не можем получить от сервера 


Т.е. по сути, код авторизации это некий код, который клиент обменивает у сервера на токен доступа. И вроде бы как это должно защищать наш токен доступа. Но я не вижу здесь никакой надежной защиты. Например, пользователь или злоумышленник может перехватить этот код авторизации. И отправить его на эндпоинт сервера авторизации, чтобы обменять на токен доступа. В результате мы получим тот же токен доступа.

Спецификация предусматривает упрощенный механизм - Неявное разрешение. Когда сервер авторизации сразу возвращает токен доступа. В результате мы сокращаем число запросов и не проигрываем в безопасности.

В спецификации сказано, что при использовании Неявного разрешения, мы должны обеспечить дополнительные проверки, чтобы клиентское приложение могло убедиться, что этот токен действительно принадлежит этому пользователю.

## Последовательность действий. Вход в систему

Сам процесс входа в систему описан в разделе ниже.

В процессе входа в систему пользователю назначается токен доступа. Этот токен позволяет проходить повторную аутентификацию в упрощенном режиме.

Есть несколько вариантов работы с токеном доступа.

1. Первый кейс

Пользователю выдается пара токенов:

- токен доступа короткого срока действия,
- токен обновления длительного срока действия или бесконечный.

По истечению срока действия токена доступа, клиентское приложение должно запросить у сервера авторизации новый токен доступа, предоставив токен обновления.

В таком варианте выход из приложения в привычном смысле невозможен. Потому что пользователь будет в системе пока не закончится срок действия токена обновления.

2. Второй кейс

Пользователю выдается только один токен доступа с бесконечным сроком.

При этом, этот токен записывается в базу данных для этого пользователя.

Проверка токена и идентификация пользователя происходит путем проверки существования токена в базе данных.

Если этот токен очистить, соответственно, произойдет выход пользователя из системы.

## Последовательность действий. Авторизация

Вы открываете клиентское приложение.

Клиентское приложение отправляет запрос на сервер авторизации.

В самом начале сервер авторизации проверяет, зарегистрировано ли указанное клиентское приложение, от которого поступил запрос. Для идентификации клиентского приложения, сервер проверяет полученные данные:

    client_id
    client_secret

[Спецификация RFC6749 2.3](https://datatracker.ietf.org/doc/html/rfc6749.html#section-2.3)

Здесь может быть два варианта:

- клиент не зарегистрирован, либо данные неверны,
- клиент зарегистрирован и данные верны.

1. Клиент не зарегистрирован, либо данные неверны

Сервер возвращает ошибку.

Дальше нет никаких действий.

2. Клиент зарегистрирован и данные верны

Сервер возвращает ответ без ошибки. Это значит, что он готов принимать данные пользователя.

Клиентское приложение отправляет данные.

Сервер авторизации запускает механизм аутентификации пользователя по представленным данным. Например, это может быть наличие токена в заголовке запроса.

Здесь может быть два варианта:

- пользователь не аутентифицирован,
- пользователь аутентифицирован.

2.1. Пользователь не аутентифицирован

Если пользователь не аутентифицирован, сервер авторизации возвращает ответ с предоставлением uri на страницу с формой входа.

Клиентское приложение открывает эту страницу и пользователь действует одним из следующих путей:

- вводит свои учетные данные для входа,
- регистрируется,
- запрашивает вход через сторонний сервис.

2.1.1. Пользователь вводит свои учетные данные для входа

Как правило, это логин и пароль.

Сервер авторизации проверяет наличие учетной записи по этим данным.

Здесь также может быть два варианта:

- учетной записи нет, либо данные не верны,
- учетная запись есть и данные верны.

2.1.1.1. Учетной записи нет, либо данные не верны

Сервер возвращает ошибку на свою же страницу с формой входа.

Пользователь может попробовать аутентифицироваться заново или выбрать другой путь из п.2.1.

2.1.1.2. Учетная запись есть и данные верны

Сервер аутентифицирует пользователя и приступает к процедуре авторизации (п.2.2).

2.1.2. Пользователь регистрируется

Сервер авторизации предоставляет форму регистрации.

После ввода всех данных, сервер создает новую учетную запись.

Для упрощенной регистрации этого может быть достаточно. Для повышения защиты могут использоваться дополнительные механизмы проверки.

Например, учетная запись пользователя будет неактивной, пока он не подтвердит свой email. Для этого сервер генерирует уникальный ключ активации, либо привязывает ключ к идентификатору (например, логину) пользователя. После регистрации, сервер отправляет пользователю письмо со ссылкой на эндпоинт api и с передачей ключа активации и, если необходимо, идентификатору пользователя. Этот эндпоинт запускает скрипт, который просто находит пользователя, проверяет ключ и активирует учетную запись.

Вместо email может быть задействован номер телефона, а ключ отправляться по СМС.

Можно сделать подобный механизм на этапе до регистрации пользователя, таким образом упростив процесс со стороны пользователя.

После того, как пользователь зарегистрирован, сервер выполняет действия из п.2.1.1.2.

2.1.3. Пользователь запрашивает вход через сторонний сервис

Например, сторонним сервисом может быть google, vk, яндекс, mail.ru и др. сервисы, поддерживающие OAuth 2.0/

Тогда сервер запускает процесс обращения к стороннему сервису, который неявно воспроизводит шаги 2.1.1 - 2.1.2.

В результате сервер получает подтвержденные (почти гарантированно) учетные данные пользователя.

Если эти учетные данные есть в его системе, он аутентифицирует пользователя (п.2.1.1.2).

Если учетных данных нет, но может автоматически зарегистрировать этого пользователя и также аутентифицировать его (п.2.1.1.2).

2.2. Пользователь аутентифицирован

Сервер переходит к процессу авторизации, т.е. выдачи прав.

Для прав используется множество механизмов. Например, CRUD в базе данных, группировка по разным уровням доступа. Но все это должно касаться только клиентского приложения и сторонних приложений.

Ответственность сервера авторизации состоит в простом определении, есть ли у пользователя права доступа к тому или иному сервису.

За это отвечают области доступа.

[Спецификация RFC6749 1.3.4](https://datatracker.ietf.org/doc/html/rfc6749.html#section-1.3.4)

В данной реализации области доступа определяют, разрешено ли данному пользователю использование клиента. Причем в данном случае клиентом может быть как само клиентское приложение, так и сторонние приложения. Нужно лишь, чтобы они были зарегистрированы в системе в качестве клиентов.

Здесь может быть два варианта:

- пользователь не авторизован,
- пользователь авторизован.

2.2.1. Пользователь не авторизован

Значит, доступ к клиенту для пользователя запрещен. Сервер возвращает клиенту ошибку.

Дальше действий нет.

2.2.2. Пользователь авторизован

Пользователю разрешен доступ к клиенту. Сервер возвращает ответ, в котором содержатся данные пользователя.

Сервер также может перейти по зарегистрированному для клиента uri редиректа и передать данные в этом uri.

[Спецификация RFC6749 3.1.2](https://datatracker.ietf.org/doc/html/rfc6749.html#section-3.1.2)

Клиент сам будет работать с этими данными.

У сервера авторизации дальше действий нет.

## Последовательность действий. Запрос стороннего приложения

Для начала определим следующее:

- наш пользователь уже авторизован в клиентском приложении,
- стороннее приложение также зарегистрировано в качестве клиента на нашем сервере авторизации,
- наш пользователь имет доступ к стороннему приложению через область доступа.

Теперь разберем несколько кейсов.

1. Первый кейс

Предположим, нам нужно войти в стороннее приложение без ввода пароля.

В этом случае мы просто должны в запросе к стороннему приложению передать свой токен.

Стороннее приложение повторит действия из п.2, п.2.2, п.2.2.2 раздела "Последовательность действий. Авторизация".

2. Второй кейс

Возьмем другую ситуацию. Нам нужно получить данные нашего же пользователя, но из стороннего приложения. Сами мы находимся в клиентском приложении.

Проще всего это сделать через обращение к эндпоинту api стороннего приложения. Этот эндпоинт будет скорее всего защищен от неавторизованных запросов и будет выдавать информацию только для конкретного пользователя.

В этом случае мы также делаем запрос к стороннему приложению и передаем свой токен.

Стороннее приложение повторит действия из п.2, п.2.2, п.2.2.2 раздела "Последовательность действий. Авторизация".

Затем выдаст ответ с данными пользователя. Клиентское приложение принимает эти данные и дальше работает с ними.

3. Третий кейс

Теперь возьмем ситуацию, когда мы обращаемся к стороннему приложению из клиентского приложения для выполнения каких-то действий от нашего имени.

Например, поделиться интересной ссылкой со всеми друзьями.

По-сути, этот тот же кейс, что и предыдущий. Проще всего это реализовать через api стороннего приложения.

В таком виде запросы будут выполняться от имени пользователя. Но для безопасности, мы должны разрешить подобные действия между приложениями. Для этого мы должны в стороннем приложении:

- подготовить эндпоинты только для приложений,
- добавить авторизацию запросов от других приложений,
- разрешать/запрещать выполнение действий другими приложениями от лица пользователя,
- разрешать/запрещать передачу данных другим приложениями от лица пользователя.

На сервере авторизации в такие запросы потребуется добавлять идентификатор клиентского приложения и другие данные, например, название приложения, описание, логотип, ссылку и т.д.

4. Четвертый кейс

Мы обращаемся к серверу авторизации из клиентского приложения, чтобы авторизовать пользователя. Если пользователь авторизован, то все ок. Мы можем выдать ему внутренний токен или другим каким-то образом связать его с нашей базой пользователей.

5. Пятый кейс

Мы обращаемся к серверу авторизации из клиентского приложения, чтобы авторизовать пользователя по протоколу OAuth 2.0, как к любому стороннему сервису авторизации.



# Схема бд

- users
- clients

Все описанные здесь запросы происходят от имени клиента. соответственно, модуль клиента реализует авторизацию по протоколу OAuth 2.0.

Простая авторизация работает и без этого модуля.

Также клиент должен быть связан с пользователем.

# Схема запросов

## Регистрация клиентского приложения

/clients/register

POST

{
    title: string,
    description: string,
    client_uri: string,
    redirect_uri: string
}

Headers

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M

Обязательно передавать этот запрос с заголовком токена авторизации пользователя. Клиент привязывается к пользователю и авторизация в этом случае обязательна.

Response

{
	"id": "27",
	"createdAt": "2024-02-27T22:33:15.647Z",
	"updatedAt": "2024-02-27T22:33:15.647Z",
	"title": "string",
	"description": "string",
	"client_uri": "string",
	"redirect_uri": "string",
	"publishedAt": "2024-02-27T22:33:15.647Z",
	"isPublished": true,
	"client_id": "887059dd-2814-43b4-81ac-d2bc21cc564f",
	"client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
}

Для валидности всех остальных запросов, ключ client_secret должен передаваться в любом из следующих двух способов.

1. В заголовке client_secret:

    client_secret: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM

2. В теле POST-запроса:

    {
        "client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
    }

Мы исключили способ передачи client_secret как Bearer-токена в заголовке authorization из-за возможных конфликтов. Ключ client_secret будет передаваться совместно с токеном пользователя. А тот, в свою очередь, будет использовать Bearer как основной способ передачи. 

## Авторизация клиентского приложения через код авторизации

/clients/authorize

POST

{
	response_type: "code",
    client_id: string
    redirect_uri: string
}

Headers

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M

Обязательно передавать этот запрос с заголовком токена авторизации пользователя. Клиент привязывается к пользователю. В данном запросе подразумевается, что клиент отдает код авторизации, который будет меняться на токен доступа клиентского приложения. При этом пользователь должен быть авторизован.

{
	"id": "27",
	"createdAt": "2024-02-27T22:33:15.647Z",
	"updatedAt": "2024-02-27T22:33:15.647Z",
	"title": "string",
	"description": "string",
	"client_uri": "string",
	"redirect_uri": "string",
	"publishedAt": "2024-02-27T22:33:15.647Z",
	"isPublished": true,
	"client_id": "887059dd-2814-43b4-81ac-d2bc21cc564f",
	"client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
}

## Авторизация клиентского приложения через код авторизации

/clients/authorize

POST

{
	response_type: "code",
    client_id: string
    redirect_uri: string
}

Headers

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M

Обязательно передавать этот запрос с заголовком токена авторизации пользователя. Клиент привязывается к пользователю. В данном запросе подразумевается, что клиент отдает код авторизации, который будет меняться на токен доступа клиентского приложения. При этом пользователь должен быть авторизован.

{
	"id": "27",
	"createdAt": "2024-02-27T22:33:15.647Z",
	"updatedAt": "2024-02-27T22:33:15.647Z",
	"title": "string",
	"description": "string",
	"client_uri": "string",
	"redirect_uri": "string",
	"publishedAt": "2024-02-27T22:33:15.647Z",
	"isPublished": true,
	"client_id": "887059dd-2814-43b4-81ac-d2bc21cc564f",
	"client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
}

## Проверка клиентского приложения

/clients/self

GET/POST

Response

{
	"id": "27",
	"createdAt": "2024-02-27T22:33:15.647Z",
	"updatedAt": "2024-02-27T22:33:15.647Z",
	"title": "string",
	"description": "string",
	"client_uri": "string",
	"redirect_uri": "string",
	"publishedAt": "2024-02-27T22:33:15.647Z",
	"isPublished": true,
	"client_id": "887059dd-2814-43b4-81ac-d2bc21cc564f",
	"client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
}

## Регистрация пользователя

/auth/register

POST

{
    username: string,
    password: string,
}

Response

{
	"id": "5",
	"createdAt": "2024-02-27T22:56:59.240Z",
	"updatedAt": "2024-02-27T22:56:59.240Z",
	"username": "test@test.ru",
	"password": "$2a$10$WcAa9r9C7njigob6GIgS3ejiyHE8WZsx6BY47g6digiVv9QeIjPtq",
	"passportStrategy": null,
	"passportId": null,
	"isActivated": false,
	"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M",
	"refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcxMTY2NjYxOX0.qLAR4f-yD3smdfXp0XhJSl5hmEULdVh8kOQxUHFGFTQ"
}

Был задан пароль:

    123456

Для валидности всех остальных запросов, ключ access_token должен передаваться в как Bearer-токен в заголовке authorization:

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M

## Авторизация пользователя

/auth/login

POST

{
    username: string,
    password: string,
}

Response

{
	"id": "5",
	"createdAt": "2024-02-27T22:56:59.240Z",
	"updatedAt": "2024-02-27T22:56:59.240Z",
	"username": "test@test.ru",
	"password": "$2a$10$WcAa9r9C7njigob6GIgS3ejiyHE8WZsx6BY47g6digiVv9QeIjPtq",
	"passportStrategy": null,
	"passportId": null,
	"isActivated": false,
	"access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M",
	"refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcxMTY2NjYxOX0.qLAR4f-yD3smdfXp0XhJSl5hmEULdVh8kOQxUHFGFTQ"
}

## Проверка пользователя

/auth/self

GET/POST

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M

Response

{
	"id": "5",
	"createdAt": "2024-02-27T22:56:59.240Z",
	"updatedAt": "2024-02-27T22:56:59.240Z",
	"username": "test@test.ru",
	"password": "$2a$10$WcAa9r9C7njigob6GIgS3ejiyHE8WZsx6BY47g6digiVv9QeIjPtq",
	"passportStrategy": null,
	"passportId": null,
	"isActivated": false
}

## Проверка запроса данных пользователя через клиента

/auth/secure

POST

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M
    client_secret: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM

POST

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M

{
    "client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
}

Response

{
	"id": "5",
	"createdAt": "2024-02-27T22:56:59.240Z",
	"updatedAt": "2024-02-27T22:56:59.240Z",
	"username": "test@test.ru",
	"password": "$2a$10$WcAa9r9C7njigob6GIgS3ejiyHE8WZsx6BY47g6digiVv9QeIjPtq",
	"passportStrategy": null,
	"passportId": null,
	"isActivated": false
}

## Серия простых запросов в другое клиентское приложение

http://localhost:5000/posts/create

POST

{
    "title": "new post"
}

Response

{
	"title": "new post",
	"content": null,
	"publishedAt": "2024-02-29T16:06:10.652Z",
	"isPublished": true,
	"id": "1",
	"createdAt": "2024-02-29T16:06:10.652Z",
	"updatedAt": "2024-02-29T16:06:10.652Z"
}

http://localhost:5000/posts/get_all

GET

Response

[
    {
        "id": "1",
        "createdAt": "2024-02-29T16:06:08.479Z",
        "updatedAt": "2024-02-29T16:06:08.479Z",
        "title": "new post",
        "content": null,
        "publishedAt": "2024-02-29T16:06:08.479Z",
        "isPublished": true,
        "tags": []
    }
]

## Проверка запроса в другое клиентское приложение

http://localhost:5000/posts/get_all

POST

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjUiLCJpYXQiOjE3MDkwNzQ2MTksImV4cCI6MTcwOTA3NTUxOX0.dGs9FrIqNyxJizid4bHmefm-8mP3oQHF8SOsNh9s9-M
    client_secret: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM

Что здесь должно быть:

- другое клиентское приложение развернуто на localhost:3001

- в другом клиентском приложении должен быть эндпоинт restapi /posts/get_all с выводом всех постов

- эндпоинт должен быть защищен от неавторизованных пользователей (например, тот же декоратор @Auth)

- другое клиентское приложение для аутентификации и проверки пользователей должно обращаться к серверу авторизации

- другое клиентское приложение может проксировать поступивший authorization на сервер авторизации

- другое клиентское приложение может проксировать поступивший client_secret на сервер авторизации

- сервер авторизации должен проверять
    * проксированный client_secret
    * client_secret другого клиентского приложения
на разрешение доступа к другому клиентскому приложению по scope
