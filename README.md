# nestapi
API backend service with REST and GrapQL based on Nest.js, TypeORM, Apollo

Этот бэк предоставляет уже готовые базовые возможности:

- управление регистрацией и авторизацией пользователей,
- получение и обработка файлов, в т.ч. изображений,
- работа с базой данных,
- RestAPI и GraphQl в любом сочетании по выбору.

Для примера бэк уже содержит несколько базовых сущностей. Обычно они нужны в любой системе в том или ином виде, так что вы можете использовать их не только в качестве примера, но и для работы.

# Пользователи

Обычно в системах данные пользователей и данные авторизации/аутентификации хранятся в одной таблице. В данном случае это две совершенно разные сущности.

Данные авторизации/аутентификации хранятся в таблице **auth**. Для работы с этими данными есть свои декораторы, DTO-шки, интерфейсы, стратегии, сервисы и пр., а также свой модуль с контроллером.

Такое разделение позволяет изолировать данные авторизации от прочих данных пользователя, а также все методы работы с ними.

Например, вы можете разрешить авторизацию по телефону и email. Вам не нужно заморачиваться с безопасностью и возможностью разделения этих данных для авторизации и для хранения в качестве контактной информации пользователя.

Также вы можете работать над авторизацией изолированно от прочих данных пользователя. Это относится, например, к реализации прав, авторизации по OAuth или OpenID и т.д.

У нас реализована авторизация с двумя jwt токенами, авторизация через google и механизм сессий.

Для контроллера у нас есть декоратор **@Auth**, который разрешает доступ только авторизованному пользователю. В этом декораторе можно указывать группу прав. Например:

    @Auth('admin')

Для пользователей у нас есть декоратор **@Self**. Например:

    ...(@Self() id: number) {...}

Его использование позволяет управлять данными именно того пользователя, от которого идет запрос.

Пользователи **users** и данные авторизации **auth** связаны между собой отношением один-к-одному по полю **id** (**auth.id**).

Предполагается, что пользователь не может просто так получить свои данные авторизации, но система позволяет их поменять. Примером такой реализации служит пароль.

# Базовые сущности

- categories - категории или разделы постов
- posts - посты
- tags - теги для постов

Каждая сущность имеет базовые поля, такие как:

- bigint
- date
- enum
- int
- text
- timestamp
- varchar

# Отношения

Посты по-умолчанию являются базовой единицей. Каждый пост привязан к какому-либо автору, поэтому посты связаны с пользователями отношением многие-к-одному.

Также посты могут относится к какой-либо категории, предполагается, что только к одной. Поэтому посты связаны с категориями тоже отношением многие-к-одному.

А вот тегов посты могут иметь несколько. И посты связаны с тегами отношением многие-ко-многим.

Для такой связи предусмотрено создание отдельной таблицы **posts_by_tags**.

Любые подобные отношения предполагают взаимное изменение и удаление. Например, пост может поменять категорию, а при удалении категорий, удалятся все посты, которые входят в нее.

Все отношения прописаны в файлах **entity**.

Вы можете поменять существующие отношения или добавить новые.

# Модели данных

Модель данных в TypeOrm автоматически формирует базу данных с необходимыми полями и связями. Также на ее основе автоматически генерируется схема GraphQl. Такие модели представлены файлами с расширением **.entity.ts**.

Также мы использем DTO - классы описания данных, которые используются для типизации передаваемых данных к сервисам. Такие модели данных представлены файлами с расширением **.dto.ts**.

Все модели данных наследуют базовый класс, который содержит поля:

- id
- createdAt
- updatedAt

Для TypeOrm это:

    src/typeorm/entity/common.entity.ts

Для DTO это:

    src/typeorm/entity/common.dto.ts

# Контроллеры

Контроллеры используются для запуска методов RestAPI. Контроллеры представлены файлами с расширением **.controller.ts**.

Для GraphQl вместо контроллеров используются резолверы. Они представлены файлами с расширением **.resolver.ts**.

Контроллеры и резолверы мы рекомендуем использовать в качестве обертки, а сам функционал реализовывать в сервисах.

# Сервисы

Сервисы представляют собой классы, которые реализуют код сервисных функций. Они представлены файлами с расширением **.service.ts**.

Мы предлагаем реализацию базовых методов для каждой сущности, что покрывает 90% всех потребностей.

Эти методы:

- получить все записи
- получить одну запись по id
- получить несколько записей по списку id

- найти все записи, поля которых соответствуют заданным условиям
- найти одну, последнюю запись, поля которой соответствуют заданным условиям

- поиск по записям, которые имеют заданные совпадения в заданных полях
- найти записи и сгруппировать их по заданному полю
- создать новую запись
- обновить запись
- удалить запись

# Работа с файлами

- users

auth
files

limit   page    skip    result
10      1       5       6 - 15


