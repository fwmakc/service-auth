# NestAPI

API backend service with RESTful and GrapQL based on Nest.js, TypeORM, Apollo

Этот бэк предоставляет уже готовые базовые возможности:

- управление регистрацией и авторизацией/аутентификацей пользователей,
- получение и обработка файлов, в т.ч. изображений,
- работа с базой данных,
- RestAPI и GraphQL в любом сочетании по выбору.

Для примера бэк уже содержит несколько базовых сущностей. Обычно они нужны в любой системе в том или ином виде, так что вы можете использовать их не только в качестве примера, но и для работы.

# Оглавление

- [Установка](#установка)
- [Запуск](#запуск)
- [Настройка](#настройка)
  - [Настройки сервера](#настройки-сервера)
  - [Настройки токенов](#настройки-токенов)
  - [Настройки базы данных](#настройки-базы-данных)
  - [Настройки GraphQL](#настройки-graphql)
  - [Настройки почты](#настройки-почты)
  - [Настройки passport](#настройки-passport)
- [Базовые сущности](#базовые-сущности)
  - [Типы сущностей](#типы-сущностей)
  - [Расширение типов сущностей](#расширение-типов-сущностей)
- [Отношения](#отношения)
- [Модели данных](#модели-данных)
- [Контроллеры и резолверы](#контроллеры-и-резолверы)
  - [Аргументы запросов](#аргументы-запросов)
  - [Методы запросов](#методы-запросов)
  - [Пути запросов](#пути-запросов)
- [Сервисы](#сервисы)
  - [Связи в сервисах](#связи-в-сервисах)
  - [Объединение сервисов](#объединение-сервисов)
- [Методы](#методы)
  - [Метод getAll](#метод-getall)
  - [Метод getOne](#метод-getone)
  - [Метод getMany](#метод-getmany)
  - [Метод getById](#метод-getbyid)
  - [Метод filter](#метод-filter)
  - [Метод search](#метод-search)
  - [Метод create](#метод-create)
  - [Метод update](#метод-update)
  - [Метод remove](#метод-remove)
  - [Опции](#опции)
    - [Опции фильтрации](#опции-фильтрации)
    - [Опции группировки](#опции-группировки)
    - [Опции технически](#опции-технически)
- [Работа с файлами](#работа-с-файлами)
  - [filesSave](#filessave)
  - [filesRename](#filesrename)
  - [filesMaxSize](#filesmaxsize)
  - [filesAllowTypes](#filesallowtypes)
  - [filesIsImage](#filesisimage)
  - [filesImageMetadata](#filesimagemetadata)
  - [filesImageResize](#filesimageresize)
  - [filesImageOversize](#filesimageoversize)
  - [convertToWebp](#converttowebp)
  - [filesImageConvert](#filesimageconvert)
  - [Интерфейс файла](#интерфейс-файла)
- [Работа с почтой](#работа-с-почтой)
  - [mailSend](#mailsend)
  - [Интерфейс файла](#интерфейс-файла)
- [Работа с базой данных](#работа-с-базой-данных)
- [Рандомайзеры](#рандомайзеры)
  - [random] (#random)
  - [randomString] (#randomstring)
  - [randomSet] (#randomset)
  - [randomNum] (#randomnum)
  - [randomBin] (#randombin)
  - [randomHex] (#randomhex)
  - [randomArray] (#randomarray)
  - [shuffleArray] (#shufflearray)
  - [randomOption] (#randomoption)
  - [randomEmail] (#randomemail)
  - [randomName] (#randomname)
- [Пользователи](#пользователи)
  - [Учетные данные пользователей](#учетные-данные-пользователей)
  - [Инициализация пользователей](#инициализация-пользователей)
  - [Активация пользователей](#активация-пользователей)
  - [Авторизация и аутентификация пользователей](#авторизация-и-аутентификация-пользователей)
  - [Получение данных пользователей](#получение-данных-пользователей)
  - [Passport js и стратегии](#passport-js-и-стратегии)
  - [Защитники](#защитники)
  - [Подключение сервиса google](#подключение-сервиса-google)
- [Токены](#токены)
  - [Токен доступа](#токен-доступа)
  - [Токен обновления](#токен-обновления)
  - [Проверка токенов](#проверка-токенов)
- [Сессии](#сессии)
  - [Информация о сессии](#информация-о-сессии)
  - [Проверка сессии](#проверка-сессии)
- [Сервер авторизации](#сервер-авторизации)
  - [Исходные данные для работы сервера авторизации](#исходные-данные-для-работы-сервера-авторизации)
  - [Процессы сервера авторизации](#процессы-сервера-авторизации)
  - [Модуль клиента](#модуль-клиента)
- [Правила именований](#правила-именований)
  - [Обычное именование](#обычное-именование)
  - [Именование в базах данных](#именование-в-базах-данных)
  - [Именование сущностей булевого типа](#именование-сущностей-булевого-типа)
  - [Именование действий](#именование-действий)
  - [Именование определений](#именование-определений)
  - [Полное и краткое именование](#полное-и-краткое-именование)
  - [Именование файлов](#именование-файлов)
  - [Что дают правила именования](#что-дают-правила-именования)

# Установка

Выполните клонирование данного репозитория в ваш проект на локальном компьютере:

```shell script
git clone https://github.com/isengine/nestapi
```

или в текущий каталог вашего проекта:

```shell script
git clone https://github.com/isengine/nestapi .
```

Для сборки и запуска проекта мы рекомендуем использовать менеджер **npm**.

```shell script
npm install
```

[^ к оглавлению](#оглавление)

# Запуск

Для сборки и запуска в режиме разработки, выполните:

```shell script
npm run dev
```

Для сборки в режиме **production**, выполните:

```shell script
npm run build
```

Для **production** мы рекомендуем использовать менеджер процессов **pm2**.

Запуск процесса:

```shell script
pm2 start dist/main.js --name nestapi
```

Перезапуск процесса:

```shell script
pm2 reload nestapi
```

Остановка процесса:

```shell script
pm2 stop nestapi
```

Мониторинг процессов:

```shell script
pm2 monit
```

Просмотр логов:

```shell script
pm2 logs nestapi --lines 1000
```

Очистить все процессы:

```shell script
pm2 kill
```

Для запуска без **pm2**, выполните:

```shell script
npm run prod
```

[^ к оглавлению](#оглавление)

# Настройка

Настройка бэка производится переменными окружения, которые лежат в файле **.env**. Этот файл небезопасно хранить в репозитории, поэтому мы предлагаем файл с примерным содержанием настроек **.env.example**.

Переименуйте или скопируйте файл **.env.example** в **.env**, а затем настройте его под ваш проект.

Некоторые настройки предусматривают значения вкл/выкл. В этом случае для включения можно использовать значение **true**, а для выключения оставить поле пустым.

Этот файл условно разделен на несколько частей.

[^ к оглавлению](#оглавление)

## Настройки сервера

- NODE_ENV - задает режим работы: **development** или **production**,
- PORT - порт, на котором будет запускаться бэк, по-умолчанию **5000**,
- DOMAIN - адрес домена, по-умолчанию **http://localhost**
- PREFIX - здесь вы можете задать глобальный префикс, например **api** и тогда бэк будет доступен по адресу **http://localhost/api**,
- UPLOADS - папка для загрузки файлов в корневом каталоге, по-умолчанию **uploads**,

[^ к оглавлению](#оглавление)

## Настройки сессии

- SESSION_SECRET - здесь должна быть любая строка из случайного количества символов, которая является ключом для механизма сессий,
- SESSION_EXPIRES=2592000 - срок жизни сессии в секундах. Желательно, чтобы он был не больше, чем **JWT_REFRESH_EXPIRES**. По-умолчанию равен 30 дням.

[^ к оглавлению](#оглавление)

## Настройки токенов

- JWT_ACCESS_SECRET - любая строка из случайных символов, является солью для токена доступа,
- JWT_ACCESS_EXPIRES - время действия токена доступа,
- JWT_REFRESH_SECRET - любая строка из случайных символов, является солью для токена обновления,
- JWT_REFRESH_EXPIRES - время действия токена обновления,
- JWT_EXPIRES - активация проверки времени действия токенов.

[^ к оглавлению](#оглавление)

## Настройки базы данных

- DB_TYPE - тип базы данных,
- DB_HOST - хост,
- DB_NAME - имя базы данных,
- DB_USER - имя пользователя для подключения к базе данных,
- DB_PASSWORD - пароль для подключения к базе данных,
- DB_PORT - порт, на котором доступна база данных,
- DB_SYNCHRONIZE - автоматическая синхронизация базы данных со схемой **TypeORM**, по-умолчанию включена, рекомендуем отключать в **production**.

В файле **.env.example** имеются базовые настройки для подключения к базе данных **MySql** и **Postgres**.

[^ к оглавлению](#оглавление)

## Настройки GraphQL

- GQL_ENABLE - разрешает использовать GraphQL,
- GQL_PLAYGROUND - разрешает использовать песочницу, которая доступна по адресу **graphql**.

По-умолчанию обе настройки влючены.

[^ к оглавлению](#оглавление)

## Настройки почты

- SMTP_HOST - хост для почты,
- SMTP_PORT - порт для почты,
- SMTP_USER - имя пользователя для подключения к почте,
- SMTP_PASSWORD - пароль для подключения к почте,
- SMTP_SECURE - режим защищенности почты,
- SMTP_SENDER_NAME - имя, от которого будет отправляться почта (может быть пустым),
- SMTP_SENDER_EMAIL - email, который будет вписан в отправителя (обычно совпадает с именем пользователя).

[^ к оглавлению](#оглавление)

## Настройки passport

Здесь хранятся различные настройки, которые вы должны взять из своих аккаунтов на сервисах типа Google authentication.

[^ к оглавлению](#оглавление)

# Базовые сущности

- categories - категории или разделы постов
- posts - посты
- tags - теги для постов

Каждая сущность имеет базовые поля, такие как:

- bigint
- date
- enum
- int
- text
- timestamp
- varchar

[^ к оглавлению](#оглавление)

## Типы сущностей

У каждой сущности есть несколько типов:

- controller
- DTO
- entity
- module
- resolver
- service

Дополнительными типами могут быть:

- decrator
- enum
- group
- interface

Также вы можете создать любой нужный вам тип.

Каждый тип сущности представлен в файле, который имеет условный шаблон **сущность.тип.ts**.

[^ к оглавлению](#оглавление)

## Расширение типов сущностей

Один тип сущности может отвечать как за один метод, так и объединять несколько методов общего вида или значения.

Если вы хотите расширить сущность, вам нужно решать, что лучше:

- создать новый тип,
- расширить существующий тип.

Если вы хотите создать собственные кастомные типы, предлагаем сделать это в отдельном файле, например **сущность.custom.тип.ts**.

Если типов много, вы можете положить их в отдельную папку. Например:

    сущность
        тип
            сущность.first.тип.ts
            сущность.second.тип.ts

> Не забудьте в этом случае следить за импортами!

[^ к оглавлению](#оглавление)

# Отношения

Посты по-умолчанию являются базовой единицей. Каждый пост привязан к какому-либо автору, поэтому посты связаны с пользователями отношением многие-к-одному.

Также посты могут относится к какой-либо категории, предполагается, что только к одной. Поэтому посты связаны с категориями тоже отношением многие-к-одному.

А вот тегов посты могут иметь несколько. И посты связаны с тегами отношением многие-ко-многим.

Для такой связи предусмотрено создание отдельной таблицы **posts_by_tags**.

Любые подобные отношения предполагают взаимное изменение и удаление. Например, пост может поменять категорию, а при удалении категорий, удалятся все посты, которые входят в нее.

Все отношения прописаны в файлах **entity**.

Вы можете поменять существующие отношения или добавить новые.

[^ к оглавлению](#оглавление)

# Модели данных

Модель данных в **TypeORM** автоматически формирует базу данных с необходимыми полями и связями. Также на ее основе автоматически генерируется схема GraphQL. Такие модели представлены файлами с расширением **.entity.ts**.

Также мы использем DTO - классы описания данных, которые используются для типизации передаваемых данных к сервисам. Такие модели данных представлены файлами с расширением **.dto.ts**.

Все модели данных наследуют базовый класс, который содержит поля:

- id
- createdAt
- updatedAt

Для TypeORM это:

    src/typeorm/entity/common.entity.ts

Для DTO это:

    src/typeorm/entity/common.dto.ts

[^ к оглавлению](#оглавление)

# Контроллеры и резолверы

Контроллеры используются для запуска методов RestAPI. Контроллеры представлены файлами с расширением **.controller.ts**.

Для GraphQL вместо контроллеров используются резолверы. Они представлены файлами с расширением **.resolver.ts**.

Контроллеры и резолверы мы рекомендуем использовать в качестве обертки, а сам функционал реализовывать в сервисах.

[^ к оглавлению](#оглавление)

## Аргументы запросов

Мы сделали так, что контроллеры и резолверы используются максимально похоже.

Резолверы принимают аргументы через переменные GraphQL запроса, а контроллеры - через тело запроса. В обоих случаях аргументы имеют формат **JSON**.

Например, для условного запроса **getOne**, требуется аргумент **id**. Для контроллера и резолвера он будет передан одинаково:

    {
        "id": 1
    }

Для получения данных из тела запроса, есть встроенный декоратор **@Body**. Но если вы используете библиотеку **axios**, вы не сможете передать данные в запрос **get**.

Мы сделали декоратор **@Data**, который объединяет данные из тела **body** и параметров **query** запроса. Декоратор имеет один аргумент, который может вытягивать из запроса только определенные данные.

Пример для контроллеров:

    ...(@Data('id') id: number) {...}

В общем, декоратор **@Data** заменяет собой **@Body**.

> Декоратор не имеет смысл использовать в резолверах.

[^ к оглавлению](#оглавление)

## Методы запросов

В реализации контроллеров мы используем стандарт RESTful API.

Так выглядит пример запроса:

```
api/resource/endpoint
```

- **api** является точкой входа,
- **resource** указывает на запрашиваемый ресурс,
- **endpoint** может содержать сложный путь, даже с некоторыми параметрами.

Параметры запроса передаются в виде JSON.

Методы запросов назначаются декораторами. Например:

```
import { ... Get, ... } from '@nestjs/common';
...

  @Get('get_all')
  async postsGetAll() {
    ...
```

Доступные методы HTTP-запросов:

- GET, получает полные данные (тело и заголовки),
- HEAD, получает только заголовки (служебную информацию),
- POST, отправляет данные на сервер,
- PUT, отправляет запрос на создание нового ресурса на сервере, либо на замену существующего,
- PATCH, отправляет запрос на изменение фрагмента ресурса,
- DELETE, отправляет запрос на удаление ресурса,
- CONNECT, устанавливает постоянную двунаправленную связь (туннель) с сервером,
- OPTIONS, отправляет запрос на получение параметров соединения,
- TRACE, отправляет запрос, и получает его обратно для сравнения (например, какую информацию промежуточные серверы добавляют или изменяют в запросе).

Методы GET, HEAD и OPTIONS считаются безопасными, потому что по установленному стандарту вызов этих методов состояния ресурса (данных на сервере) не изменяет. Остальные - нет. Поэтому сервер должен обязательно их проверять.

По-умолчанию методы GET и HEAD кэшируются, остальные - нет. Поэтому при использовании метода POST можно быть уверенным, что запрос выполнится. В случае с GET Вы можете получить ответ из кэша, так что запрос напрямую до сервера может и не дойти.

Однако в использовании методов есть проблема, связанная с тем, что библиотеки фронтенда могут работать не со всеми методами. Поэтому мы предлагаем реализацию в контроллерах двух методов: GET и POST, однако также обеспечиваем поддержку всех остальных.

[^ к оглавлению](#оглавление)

## Пути запросов

Глобальный префикс пути настраивается в файле **.env** в переменной окружения **PREFIX**.

Если вы используете для вашего API отдельный домен, вы можете оставить пустой путь:

```
PREFIX=
```

Вы можете задать глобальный префикс, например **api** и тогда бэк будет доступен по адресу **http://localhost/api**

Если вы используете разные версии API, то вы можете добавить к пути номер версии. Например, так:

```
PREFIX=/api/v3
```

Пути к методам API задаются в контроллерах:

```
@Controller('posts')
export class PostsController {
  ...

  @Get('get_all')
  async postsGetAll() {
    ...
```

Данный метод будет вызван по адресу запроса

    /posts/get_all

Если вы использовали глобальный префикс, например **api**, то адрес будет таким:

    /api/posts/get_all

[^ к оглавлению](#оглавление)

# Сервисы

Сервисы представляют собой классы, которые реализуют код сервисных функций. Они представлены файлами с расширением **.service.ts**.

Сервисы реализуют методы, которые перечислены в соответствующем разделе.

Однако, могут возникнуть ситуации, когда некоторые методы окажутся для вас избыточными. В таком случае, вы можете просто удалить их из контроллера и резолвера.

[^ к оглавлению](#оглавление)

## Связи в сервисах

При проектировании системы неизбежно появляется большое число отношений. В запросах эти отношения указываются через связи. Но слишком большое число связей в запросах приводит к тому, что из базы подтягивается множество лишних полей. Такие запросы потребляют много памяти, забивают канал передачи данных и вызывают большие задержки.

Чтобы этого избежать, связи необходимо указывать в каждом запросе.

Связи передаются в аргументе **relations** и задаются массивом объектов **RelationsDto**:

    "relations": [
        {
            "name": "category",
            "order": "id",
            "desc": false
        }
        {
            "name": "tags",
            "order": "id",
            "desc": false
        }
        ...
    ]

Параметр **name** задает имя объекта (таблицы), который будет использован для связывания.

Параметры **order** и **desc** являются необязательными и служат для сортировки связанных объектов в переданном ответе. По-умолчанию, сортировка идет по полю **id** в порядке возрастания.

Такие связи, например, для постов позволяют получить категорию поста и все его теги в виде вложенного объекта и массива объектов соответственно.

Аргумент **relations** всегда стоит последним в запросе и является необязательным.

Например:

    postsGetAll()
    postsGetAll(relations)

Вы можете даже использовать двухуровневые связи типа **post.category**, но только если вложенные сущности не дублируют исходную сущность.

Многоуровневые связи типа **post.category.posts** создавать нельзя из-за возникновения перекрестного объединения сущностей.

[^ к оглавлению](#оглавление)

## Объединение сервисов

Чтобы объединять сервисы одной сущности, в файле **.module.ts** источника запровайдите их таким образом:

    @Module({
        ...
        providers: [PostsService, PostsCustomService],
        ...
    })

Возможно, вам также понадобится объединять сервисы разных сущностей.

Для этого в файле **.module.ts** источника импортируйте модули источника целиком:

    @Module({
        ...
        imports: [
            ...
            forwardRef(() => TestsModule),
        ],
        ...
    })

> Не забудьте импортировать **forwardRef** из библиотеки **@nestjs/common**!

После в сервисе получателя, в конструкторе, объявите сервисы источника таким образом:

    constructor(
        @InjectRepository...
        private readonly testsService: TestsService,
    ) {}

Важно следить за тем, чтобы не получилось перекрестного объединения, когда источник попадает в получателя, но получатель при этом является источником для своего источника.

[^ к оглавлению](#оглавление)

# Методы

Мы предлагаем реализацию базовых методов для каждой сущности, что покрывает 90% всех потребностей.

Методы условно разбиты на три группы:

- стандартные методы получения данных
- расширенные методы получения данных, такие как поиск, сортировка и группировка
- методы изменения данных

Эти методы:

- get all - получить все записи
- get one - получить одну запись по id
- get many - получить несколько записей по списку id
- filter - найти записи, поля которых соответствуют заданным условиям
- search - поиск по записям, которые имеют заданные совпадения в заданных полях
- create - создать новую запись
- update - обновить запись
- remove - удалить запись

Важно учитывать, что в сервисах и резолверах эти методы имеют впереди название сущности и пишутся в стиле camelCase. Например:

    postsGetAll

В контроллерах эти методы записываются в стиле snake_case. Название сущности задается в имени контроллера. Например:

    get_all
    /posts/get_all

Далее следует подробная реализация данных методов.

[^ к оглавлению](#оглавление)

## Метод getAll

Получить все записи

RestAPI:

    GET get_all

GraphQL:

    query getAll {
        result: getAll {
            ...
        }
    }

Параметры:

    нет

Ответ:

    {
        "data": {
            "result": [
                {
                    ...
                },
                ...
            ]
        }
    }

В ответ попадает массив записей с запрошенными полями.

[^ к оглавлению](#оглавление)

## Метод getOne

Получить одну запись по id

RestAPI:

    GET get_one

GraphQL:

    query getOne($id: Float!) {
        result: getOne(id: $id) {
            ...
        }
    }

Параметры:

    {
        "id": ...
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

В ответ попадает одна запись с запрошенными полями.

[^ к оглавлению](#оглавление)

## Метод getMany

Получить несколько записей по списку id

RestAPI:

    GET get_many

GraphQL:

    query getMany($ids: GetManyDto!) {
        result: getMany(ids: $ids) {
            ...
        }
    }

Параметры:

    {
        "ids": [...]
    }

Ответ:

    {
        "data": {
            "result": [
                {
                    ...
                },
                ...
            ]
        }
    }

В ответ попадает массив записей с запрошенными полями.

[^ к оглавлению](#оглавление)

## Метод getById

Это общее название подобных методов. Чаще всего они встречаются в служебных сущностях, таких как **user**.

Эти методы нужны для получения всех записей, которые привязанны к другой сущности.

Например, часто используется метод **GetByUserId**, в который передается **id** текущего пользователя. Разберем работу на его примере.

Получить несколько записей по user_id

RestAPI:

    GET get_by_user_id

GraphQL:

    query getByUserId($id: Float!) {
        result: GetByUserId(id: $id) {
            ...
        }
    }

Параметры:

    {
        "id": ...
    }

Ответ:

    {
        "data": {
            "result": [
                {
                    ...
                },
                ...
            ]
        }
    }

В ответ попадает массив записей с запрошенными полями.

[^ к оглавлению](#оглавление)

## Метод filter

Найти записи, поля которых соответствуют заданным условиям

RestAPI:

    GET filter

GraphQL:

    query filter($filter: ...Dto!, $options: OptionsDto!, $relations: [RelationsDto!]) {
        result: filter(filter: $filter, options: $options, relations: $relations) {
            count
            group
            pages
            list {
                ...
            }
        }
    }

Параметры:

    {
        "filter": {
            ...
        },
        "options": {
            "order": "id",
            "desc": false,
            "skip": 0,
            "limit": 10,
            "page": 1,
            "group": "field",
            "type": ""
        },
        "relations": [
            {
                "name": ...,
                "order": "id",
                "desc": false
            }
            ...
        ]
    }

Ответ:

    {
        "data": {
            "result": [
                {
                    "count": ...,
                    "pages": ...,
                    "group": ...,
                    "list": [
                        { ... },
                        ...
                    ]
                },
                ...
            ]
        }
    }

В параметрах **filter** вы можете указывать поля и разные запросы по их поиску и фильтрации в качестве значений.

Например:

    "filter": {
        "title": "like '%слово%'"
    }

Если в значениях нужно использовать название поля, рекомендуем писать **{alias}**. Например:

    "filter": {
        "id": ">= 20 and {alias} <= 100"
    }

Вы также можете фильтровать поля отношений. Например:

    "filter": {
        "category": {
            "title": "like '%слово%'"
        }
    }

Параметры **options.group** и **options.type** позволяют найти записи и сгруппировать их по заданному полю.

> Этот метод поддерживает опции, подробнее см. ниже

> Этот метод поддерживает связи, подробнее см. выше

Чтобы этот метод работал корректно, вам нужно расширить стандартный тип **FilterType** записью вашей сущности. Например:

    import { ObjectType } from '@nestjs/graphql';
    import { ...Entity } from '@src/.../....entity';
    import { FilterType } from '@src/typeorm/types/filter.type';

    @ObjectType()
    export class ...Filter extends FilterType(...Entity) {}

Вы можете посмотреть, как реализованы файлы  **сущность.filter.ts**.

[^ к оглавлению](#оглавление)

## Метод search

Поиск по записям, которые имеют заданные совпадения в заданных полях

RestAPI:

    GET search

GraphQL:

    query search($search: SearchDto!, $options: OptionsDto!) {
        result: search(search: $search, options: $options) {
            count
            group
            pages
            list {
                ...
            }
        }
    }

Параметры:

    {
        "search": {
            "string": "value",
            "array": ["value1", "value2"],
            "fields": ["field1", "field2"],
            "where": {
                "field": "value",
                "field.sub": "value"
            }
        },
        "options": {
            "order": "id",
            "desc": false,
            "skip": 0,
            "limit": 10,
            "page": 1,
            "group": "field",
            "type": ""
        },
        "relations": [
            {
                "name": ...,
                "order": "id",
                "desc": false
            }
            ...
        ]
    }

Ответ:

    {
        "data": {
            "result": [
                {
                    "count": ...,
                    "pages": ...,
                    "group": null,
                    "list": [
                        { ... },
                        ...
                    ]
                }
            ]
        }
    }

В параметрах **search** вы можете указывать поля и разные запросы. Значения полей **fields** будут объединены для поиска в них совпадения (like) строки **string** или всех строк массива **array** в любом порядке.

Например:

    "search": {
        "array": ["a", "b", "c"],
        "fields": ["title", "description"]
    }

Для корректной работы лучше задать только один из параметров **string** или **array**. Если указать оба, значения объединяться, но результат может оказаться неожиданный.

Если вам нужна дополнительная выборка по определенным полям, можно указать их в объекте **where**.

Например:

    "search": {
        ...
        "where": {
            "user.id": 1
        }
    }

> Этот метод поддерживает опции, подробнее см. ниже

> Этот метод поддерживает связи, подробнее см. выше

[^ к оглавлению](#оглавление)

## Метод create

Создать новую запись

RestAPI:

    GET create

GraphQL:

    mutation create($create: ...Dto!) {
        result: create(create: $create) {
            ...
        }
    }

Параметры:

    {
        "create": {
            ...
        }
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

В результат попадают запрошенные поля.

[^ к оглавлению](#оглавление)

## Метод update

Обновить запись

RestAPI:

    GET update

GraphQL:

    mutation update($update: ...Dto!) {
        result: update(update: $update) {
            ...
        }
    }

Параметры:

    {
        "update": {
            ...
        }
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

В результат попадают запрошенные поля.

[^ к оглавлению](#оглавление)

## Метод remove

Удалить запись

RestAPI:

    GET remove

GraphQL:

    mutation remove($id: Float!) {
        result: remove(id: $id)
    }

Параметры:

    {
        "id": ...
    }

Ответ:

    {
        "data": {
            "result": ...
        }
    }

В результат попадает число удаленных записей. Если ни одна запись не удалена, в результате будет **0**.

[^ к оглавлению](#оглавление)

## Опции

Есть методы, которые поддерживают опции.

К опциям относятся:

- order - сортировка по полю,
- desc - сортировка в обратном порядке,
- skip - пропустить какое-то количество записей,
- limit - получить только указанное количество записей,
- page - номер страницы,
- group - поле, по которому записи будут сгруппированы,
- type - тип группировки.

Если не указывать опции, то эти методы будут выводить все найденные записи в **list** с подсчетом из числа в **count**.

[^ к оглавлению](#оглавление)

### Опции фильтрации

Если вы задаете поле **limit**, то автоматически включается поддержка страниц **page**. Например, вы можете указать лимит 10 записей, и по-умолчанию вам будут выданы записи с 1 по 10.

Но если вы укажете страницу 2, то вам будут выданы записи с 11 по 20.

Также в ответе вам будет выдано общее число страниц **pages**.

Независимо от опций фильтрации, в ответе вам будет выдано общее число записей **count**. На данные этого счетчика не влияют **skip**, **limit** и **page**.

[^ к оглавлению](#оглавление)

### Опции группировки

Группировка - еще одна интересная вещь. Вы можете сгруппировать данные по какому-либо полю. Причем в указании поля поддерживаются отношения. Например **title** и **category.title**.

В случае с имеющимися отношениями, такая группировка может быть необоснована. Например, вы можете получить записи по категориям, запросив категории со вложенным массивом записей.

Однако, если вы хотите группировать записи по другому признаку, например по какому-либо полю, например, по дате создания, такая группировка может помочь.

Также группировка может помочь избежать создания перекрестных отношений.

В типе группировки вы можете указать следующие значения:

- string - строка,
- number - число,
- boolean - булев тип, true/false,
- другое - дата.

Если указать любое другое значение, то оно будет распознано как формат даты. Например **YYYY.MM.DD**.

> Для преобразования дат используется библиотека **moment.js**. 

Указывая тип, значение поля будет принудительно приведено к этому типу.

Если значение не указывать, то тип останется таким же, как в оригинальном поле.

В случае применения группировки, в ответе будет массив из нескольких объектов, у каждого из которых в поле **group** будет значение поля группировки.

Например, ответ без группировки:

    {
        "data": {
            "result": [
                {
                    "count": ...,
                    "group": null,
                    "list": [
                        { ... },
                        ...
                    ]
                }
            ]
        }
    }

Например, ответ с группировкой:

    {
        "data": {
            "result": [
                {
                    "count": ...,
                    "group": "...",
                    "list": [
                        { ... },
                        ...
                    ]
                },
                {
                    "count": ...,
                    "group": "...",
                    "list": [
                        { ... },
                        ...
                    ]
                },
                ...
            ]
        }
    }

В ответе вам также будет выдано число записей **count**, но для каждой группы отдельно.

Вы можете использовать вместе с группировкой и другие опции, но будьте осторожны, т.к. результат может оказаться не тем, который вам нужен.

Например, в группы не попадут записи по лимитам, а сортировка групп будет происходить на основе сортировки записей. Если сортировку не указать принудительно, то сортировка будет идти по тому же полю, что и группировка.

> Для сортировки групп в обратном порядке, рекомендуем указывать только опцию **desc: true**.

[^ к оглавлению](#оглавление)

### Опции технически

Поля опций заданы в файле **src/typeorm/dto/options.dto.ts**.

Сервисные функции, которые обрабатывают эти поля, заданы в файле **src/typeorm/services/options.service.ts**.

Чтобы не вызывать каждую функцию отдельно, мы включили сервисную функцию **optionsService**, которая, собственно подготавливает объект опций.

Кроме этого, она также вызывает репозиторий **typeorm** на выполнение, поэтому она требует передать ей репозиторий в качестве одного из аргументов.

Другими словами, **optionsService** подготавливает запрос, выполняет его и возвращает результат.

[^ к оглавлению](#оглавление)

# Работа с файлами

На текущий момент загрузка файлов возможна только через контроллер. Резолверы не поддерживаются.

Контроллер **files** реализует только один метод **upload**, который поддерживает query-параметр **folder**.

Этот параметр нужен для того, чтобы загружать файл во вложенную папку. Однако, поддерживается только один уровень вложений, чтобы сделать простую структуру хранения файлов.

Изначальная папка для загрузки файлов задается в **.env** файле, в параметре **UPLOADS**.

Метод позволяет загружать несколько файлов одновременно, устанавливать максимально допустимый размер и разрешенные типы файлов.

Кроме того, метод конвертирует изображения в формат **webp**, ужимая большие до заданных пределов с сохранением соотношения сторон.

> для работы с изображениями используется библиотека **sharp**.

В качестве результата выдается массив с расширенной информацией о каждом файле:

- url - ссылка на файл,
- originalname - имя файла,
- mimetype - mime-тип,
- size - размер в байтах.

Для работы с файлами, вы можете построить свои контроллеры, используя существующие сервисные функции.

[^ к оглавлению](#оглавление)

## filesSave

Сохраняет файлы в заданную вложенную папку.

В случае ошибки при записи файла, выбрасывает исключение.

Принимает аргументы:

- массив экземпляров интерфейса,
- вложенную папку (строка), необязательный.

Возвращает массив экземпляров интерфейса.

[^ к оглавлению](#оглавление)

## filesRename

Дает файлу новое имя в виде случайно сгенерированного набора символов по стандарту **uuid** версии 4.

Принимает аргументы:

- экземпляр интерфейса,
- расширение (строка), необязательный.

Возвращает экземпляр интерфейса.

[^ к оглавлению](#оглавление)

## filesMaxSize

Вычисляет, соответствует ли файл заданному размеру.

Если размер не указан или равен 0, то файл всегда будет соответствовать.

Принимает аргументы:

- экземпляр интерфейса,
- максимальный размер (число), необязательный.

Возвращает true/false.

[^ к оглавлению](#оглавление)

## filesAllowTypes

Вычисляет, соответствует ли файл заданному типу.

Тип может быть указан как один из mime-типов, либо его часть, либо массив.

Например:

    'jpeg'
    'image/jpeg'
    'image/*'
    'image'
    ['jpeg', 'png', 'webp']
    ['audio', 'image', 'video']

Если тип не указан, то файл всегда будет соответствовать.

Принимает аргументы:

- экземпляр интерфейса,
- типы (строка или массив строк), необязательный.

Возвращает true/false.

[^ к оглавлению](#оглавление)

## filesIsImage

Вычисляет, является ли файл изображением.

Работает по mime-типу файла.

Принимает аргументы:

- экземпляр интерфейса.

Возвращает true/false.

[^ к оглавлению](#оглавление)

## filesImageMetadata

Возвращает метаданные изображения.

Работает через библиотеку **sharp**.

Принимает аргументы:

- буфер.

Возвращает метаданные.

[^ к оглавлению](#оглавление)

## filesImageResize

Меняет размер изображения, ширину и высоту.

В качестве опций можно указать объект:

    {
        width,
        height,
        fit,
        position,
        background,
        kernel
    }

Работает через библиотеку **sharp**.

Подробнее обо всех параметрах можно узнать в документации на библиотеку.

Принимает аргументы:

- буфер,
- опции.

Возвращает буфер.

[^ к оглавлению](#оглавление)

## filesImageOversize

Меняет размер изображения если оно превышает заданные ширину или высоту.

Сохраняет соотношение сторон.

В качестве опций можно указать объект:

    {
        width,
        height
    }

Работает через функцию **filesImageResize**.

Принимает аргументы:

- буфер,
- опции.

Возвращает буфер.

[^ к оглавлению](#оглавление)

## convertToWebp

Конвертирует изображение в формат **webp**.

Работает через библиотеку **sharp**.

Принимает аргументы:

- буфер.

Возвращает буфер.

[^ к оглавлению](#оглавление)

## filesImageConvert

Конвертирует все изображения, кроме **svg**, в формат **webp**.

Работает через функцию **convertToWebp**.

Принимает аргументы:

- буфер.

Возвращает экземпляр интерфейса.

[^ к оглавлению](#оглавление)

## Интерфейс файла

Вся работа с файлами ведется через интерфейс, который содержит следующие поля:

- buffer - буфер с содержимым файла, необязательное,
- originalname - имя файла,
- mimetype - mime-тип файла,
- url - ссылка на файл, необязательное,
- size - размер в байтах, необязательное,
- width - ширина, только для изображений, необязательное,
- height - высота, только для изображений, необязательное.

Интерфейс создается через конструктор класса, который принимает файл в формате **Express.Multer.File** или экземпляр интерфейса.

[^ к оглавлению](#оглавление)

# Работа с почтой

Для работы с почтой мы используем средства **Nest.js**, которые по-сути являются надстройкой над библиотекой **Nodemailer**.

Пока что мы реализовали только отправку почты. Но в дальнейшем планируем расширить функционал до того, чтобы можно было реализовать полнофункциональный почтовый веб-интерфейс.

Базовые настройки соединения с почтым сервером задаются в переменных окружения, в секции с параметрами **SMTP**.

[^ к оглавлению](#оглавление)

## mailSend

Отправляет письмо.

Принимает аргументы:

- объект с опциями,
- массив файлов.

Возвращает результат отправки.

Объект опций **options** задан классом **MailDto** и имеет следующие поля:

- from - отправитель (пока не поддерживается), строка, проферка на соответствие формату email, необязательное,
- to - получатель, строка, проферка на соответствие формату email, обязательное,
- subject - тема письма, строка, необязательное,
- text - тест письма в формате **plain/text**, строка, необязательное,
- html - тест письма в формате **html**, строка, необязательное.

Как видите, все поля, за исключением **to** являются необязательными, а значит, их можно пропустить. Однако мы рекомендуем по-возможности заполнять все поля.

Поля **text** и **html** повторяют друг друга. На самом деле рекомендуется использовать только поле **html**, но **text** также может быть заполнен и отправлен в качестве поддержки старого формата.

Для отправки файлов используется второй аргумент **files**, который представляет собой массив объектов типа **FilesInterface**. Подробнее о нем можно посмотреть в разделе **Интерфейс файла**.

Однако на выходе мы уже получаем массив объектов другого типа - **mailAttachmentsInterface**. Он содержит следующие поля:

- filename - имя файла,
- content - строка, содержащая содержимое буфера файла, обычно кодированное в формат **base64**,
- encoding - строка, формат кодировки, обычно используют **base64**,
- contentType - mime-тип файла.

Содержимое этих полей можно взять из **FilesInterface**, но поле **content** скорее всего придется преобразовывать из буфера.

За отправку файлов отвечает контроллер **mail/send**. Данные отправляются методом **POST**.

Для отправки опций используйте поля **options[...]**. Например:

    options[to] = mail@site.ru
    options[subject] = Тема сообщения
    options[html] = <html><body><p>Текст сообщения</p></body></html>

Для отправки файлов используйте поля **file[]**. Например:

    file[] = file1.jpg
    file[] = file2.jpg

Ответ на успешно доставленное сообщение выглядит так:

    {
        "accepted": [
            "...to..."
        ],
        "rejected": [],
        "ehlo": [ ... ],
        "envelopeTime": ...,
        "messageTime": ...,
        "messageSize": ...,
        "response": "250 2.0.0 Ok: queued as CEBF34018D",
        "envelope": {
            "from": "...from...",
            "to": [
                "...to..."
            ]
        },
        "messageId": "<...>"
    }

[^ к оглавлению](#оглавление)

# Работа с базой данных

Для работы с базой данных мы используем библиотеку **TypeORM**.

Она позволяет синхронизировать изменения в БД, а также гибко управлять миграциями.

Возможно, в режиме разработки вам это не понадобится, но это станет необходимым при синхронизации изменений в локальной и **production** базах данных, а также при выключенной автоматической синхронизации в **.env** файле, в параметре **DB_SYNCHRONIZE**.

Для всего процесса миграции мы задали скрипты, которые еще больше автоматизируют весь процесс.

В начале работы вам наверняка потребуется сделать первую миграцию. Для этого используйте:

```shell script
npm run migration:fake
```

Далее, чтобы создать миграцию, выполните:

```shell script
npm run migration:auto
```

Запустить ее вы можете так:

```shell script
npm run migration:run
```

Откатить миграцию вы можете так:

```shell script
npm run migration:revert
```

Помните, что вам также необходимо, чтобы миграции были записаны в базе данных. Поэтому содержимое папки **src/typeorm/migrations** и таблицу **migrations_typeorm** тоже можно синхронизировать.

Кстати, название таблицы можно задать в файле **src/config/db.config.ts**, в параметре **migrationsTableName**.

[^ к оглавлению](#оглавление)

# Рандомайзеры

Рандомайзеры представлены методами сервиса **RandomService**, располагающегося по адресу **src/random/random.service**.

Все методы используются контроллерами группы **random**.

На данный момент резолверы реализуются в тестовом режиме и могут не работать.

Из файла экпортируется не сам класс, а новый экземпляр класса. Поэтому после импорта, можно сразу вызывать методы.

```
import randomClass from '@src/class/random.class';
...
const num = randomClass.random(1, 10);
```

[^ к оглавлению](#оглавление)

## random

**random(min, max, step = 1)**

Генератор случайных чисел.

От **min** до **max** с шагом **step** (по-умолчанию, 1).

Например вызов **random(1, 10)** выдаст число от 1 до 10.

Вызов **random(1, 10, 5)** выдаст число 5 или 10.

Вызов **random(0, 1, 0.1)** выдаст одно из чисел: 0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.

Можно указать отрицательные числа.

[^ к оглавлению](#оглавление)

## randomString

**randomString(min, max, string)**

Генератор случайных строк.

От **min** до **max** символов.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

Аргумент **string** задает строку, из которой будут браться символы.

Например: **randomSet(1, 10, 'abcdef')**.

[^ к оглавлению](#оглавление)

## randomSet

**randomSet(min, max, name)**

Генератор случайных строк из заранее составленных подборок.

От **min** до **max** символов.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

Аргумент **name** задает список подробок. Вы можете перечислить несколько подборок через запятую и/или пробел: **randomSet(1, 10, 'en, ru')**.

- **ru** - буквы русского языка в нижнем регистре,
- **RU** - буквы русского языка в верхнем регистре,
- **en** - латинские буквы в нижнем регистре,
- **EN** - латинские буквы в верхнем регистре,
- **num** - цифры,
- **hex** - цифры и буквы от 0 до F, которыми обозначаются числа в 16-ой системе исчисления,
- **sym** - символы.

[^ к оглавлению](#оглавление)

## randomNum

**randomNum(min, max)**

Генератор **строки** из случайных чисел.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

[^ к оглавлению](#оглавление)

## randomBin

**randomBin(min, max)**

Генератор **строки** из случайных чисел в 2-ой системе исчисления.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

[^ к оглавлению](#оглавление)

## randomHex

**randomHex(min, max)**

Генератор **строки** из случайных чисел в 16-ой системе исчисления.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

[^ к оглавлению](#оглавление)

## randomArray

**randomArray(n, callback)**

Генератор массива заданной длины.

Аргумент **n** задает длину массива.

В аргумент **callback** можно передать функцию, которая будет заполнять массив элементами. На вход функции подается текущий элемент.

По-умолчанию массив заполняется значениями от 0 до заданной длины.

Если вы хотите создать пустой массив, можно использовать: **randomArray(10, () => null)**.

Если вы хотите создать массив со значениями от 1, можно использовать: **randomArray(10, (i) => i + 1)**.

Вы также можете заполнить массив случайными значениями, например: **randomArray(10, () => random(1, 10))**.

[^ к оглавлению](#оглавление)

## shuffleArray

**shuffleArray(array)**

Перемешивает элементы массива случайным образом.

Возвращает новый массив, при этом старый не изменяется.

[^ к оглавлению](#оглавление)

## randomOption

**randomOption(...args)**

Выбор случайного значения, одного из переданных.

В аргумент **args** можно передать два типа значений.

- последовательность, например: **randomOption(1, 2, 3)**,

- массив, например: **randomOption([1, 2, 3])**.

[^ к оглавлению](#оглавление)

## randomEmail

**randomEmail(min, max)**

Генератор email-адреса в правильном формате.

Пределы **min** и **max** являются относительными, потому что после генерации следует небольшая чистка по условиям.

Рекомендуется запускать с параметрами по-умолчанию: **randomEmail()**

[^ к оглавлению](#оглавление)

## randomNames

**randomName(...)**

Сложный метод генерации псевдоимен.

Используется только как вспомогательный метод.

Вместо него можно использовать другие методы:

**randomNames(words = 1)**

Аргумент **words** задает число слов в имени.

На выходе отдается массив. Первым индексом идет признак рода имени:

- 0 - женский род,
- 1 - мужской род.

Чтобы получить строку с именем и фамилией, можно вызвать метод так: **name = randomRuName(2); fullName = \`\${name[1]} \${name[2]}\`**.

**randomRuNames(words = 1)**

Генератор псевдоимен с русскими буквами.

Слова генерируются в таком порядке: имя, фамилия, отчество.

**randomEnNames(words = 1)**

Генератор псевдоимен с латинскими буквами.

Слова генерируются в таком порядке: фамилия, имя, второе имя и т.д.

[^ к оглавлению](#оглавление)

# Пользователи

Обычно в системах данные пользователей и данные авторизации/аутентификации хранятся в одной таблице. В данном случае это две совершенно разные сущности.

Данные авторизации/аутентификации хранятся в таблице **auth**. Для работы с этими данными есть свои декораторы, DTO-шки, интерфейсы, стратегии, сервисы и пр., а также свой модуль с контроллером.

Такое разделение позволяет изолировать данные входа от прочих данных пользователя, а также все методы работы с ними.

Например, вы можете разрешить вход по телефону и email. Вам не нужно заморачиваться с безопасностью, разделением и хранением этих данных.

Также вы можете работать над авторизацией/аутентификацей изолированно от прочих данных пользователя. Это относится, например, к реализации прав, подключению сервисов OAuth, OpenID и т.д.

[^ к оглавлению](#оглавление)

## Учетные данные пользователей

Таблица учетных данных пользователей содержит следующие поля:

- id,
- created_at,
- updated_at,
- username,
- password,
- passport_strategy,
- passport_id,
- is_activated.

По полю **id** мы связываем запись авторизации/аутентификации с другими данными пользователя, хранящимися в таблице **users**.

Мы предполагаем, что поле **username** будет содержать email пользователя, но можно хранить там и номер телефона, и просто логин, как было принято в старых системах.

Пароли по-умолчанию хэшируются алгоритмом **bcrypt**.

Поле **is_activated** служит для подтверждения того, что регистрация пользователя подтверждена и он является активным.

[^ к оглавлению](#оглавление)

## Инициализация пользователей

Мы разбили инициализацию пользователей на несколько этапов:

- регистрация,
- активация,
- вход в систему,
- аутентификация,
- авторизация.

Здесь мы рассмотрим механизм регистрации и непосредственно входа.

Вход в систему осуществляется через контроллер и резолвер:

- /auth/login/
- query login

Регистрация осуществляется через контроллер и резолвер:

- /auth/register/
- query register

В обоих случаях на вход нужно подать объект из полей:

- username,
- password.

Для резолвера этот объект должен быть помещен в дополнительный объект верхнего уровня **login** или **register**.

> Для отслеживания временной зоны, рекомендуем передавать ее в заголовке **timezone**! Это относится к разделу истории.

В случае успеха, методы генерируют пару токенов, осуществляют запись в историю и возвращают объект данных авторизации/аутентификации вместе с токенами.

Также создается сессия, в которую записывается **refresh** токен. Затем, при перевыпуске токенов, он будет сверяться с присутствием в сессионных данных.

[^ к оглавлению](#оглавление)

## Активация пользователей

Эта функция используется по-умолчанию.

Для ее работы используется отдельная таблица **confirm**, включая одноименную папку, а также все необходимые контроллеры и сервисы.

Вы можете отключить механизм подтверждения. Для этого достаточно записывать значение **true** в поле **is_activated** при регистрации.

Код подтверждения генерируется двумя методами:

- randomSet(len, 0, 'en EN num') - создает строку из цифр и букв латинского алфавита заданной длины,
- randomNum(len) - создает строку из цифр заданной длины.

> Обратите внимание, числовой код подтверждения хранится в виде строковой переменной.

Каждый код является уникальным.

После генерации проверяется существование данного кода в таблице, и если он повторяется, генерируется новый код.

Двухфакторная аутентификация подразумевает подтверждение входа дополнительным кодом каждый раз при входе пользователя в систему. Для этого достаточно поменять код таким образом, чтобы поле **is_activated** сбрасывалось после каждого успешного входа.

[^ к оглавлению](#оглавление)

## Авторизация и аутентификация пользователей

У нас реализован механизм с двумя **jwt** токенами:

- **access** - токен доступа,
- **refresh** - токен обновления.

Токены кодируются, но не шифруются. Это значит, что прочесть содержимое токена можно в любом случае. Защита обеспечивается проверкой подлинности подписи. Эта подпись уже зашифрована ключем, который хранится только на сервере.

Мы предлагаем использовать декоратор метода **@Auth**, который разрешает доступ к ресурсу только вошедшему пользователю.

Декоратор имеет один аргумент, являющийся типом. Сейчас типов два - **undefined** для контроллеров (задан по-умолчанию) и **gql** для резолверов.

Пример для контроллеров:

    @Auth()

Пример для резолверов:

    @Auth('gql')

Внутри этот декоратор использует защитников:

- GqlAuthGuard,
- JwtAuthGuard.

Защитники **GqlAuthGuard** и **JwtAuthGuard** используют встроенный механизм библиотеки **jwt**. По-сути, мы только задаем правила стратегии **JwtStrategy** в файле **src/auth/strategy/jwt.strategy**.

А конкретно:

- получаем токен из поля **Authorization** в формате **Bearer**,
- задаем ключ для шифрования подписи **jwt** через **JWT_ACCESS_SECRET**,
- разрешаем или запрещаем учитывать время действия токена через **JWT_EXPIRES**,
- проверяем валидность данных, хранящихся в токене, сравнивая по базе данных.

Из базы данных, из таблицы **auth**, запрашивается запись по **auth.id**, и если такая запись существует, то вход подтверждается.

Если токен будет перехвачен злоумышленником, то расшифровка **auth.id** не позволит ему сопоставить значение из запроса и данные пользователя.

[^ к оглавлению](#оглавление)

## Получение данных пользователей

Для получения данных пользователей, у нас есть декоратор аргумента **@Self**.

> Декоратор аргумента **@Self** не будет работать без декоратора метода **@Auth**!

Декоратор имеет один аргумент, являющийся типом. Сейчас типов два - **undefined** для контроллеров (задан по-умолчанию) и **gql** для резолверов.

Пример для контроллеров:

    ...(@Self() id: number) {...}

Пример для резолверов:

    ...(@Self('gql') id: number) {...}

Пользователи **users** и данные авторизации/аутентификации **auth** связаны между собой отношением один-к-одному по полю **id** (**auth.id**).

Поэтому дальше вы можете запросить из базы данные пользователя по его **auth.id**. Например:

```
return await this.usersService.usersGetByAuthId(id);
```

Использование этого декоратора позволяет управлять данными именно того пользователя, от которого идет запрос.

Предполагается, что пользователь не может просто так получить свои данные для входа, но система позволяет их поменять. Примером служит смена и восстановление пароля.

[^ к оглавлению](#оглавление)

## Passport js и стратегии

Для входа через сторонние сервисы используется библиотека **passport.js**.

В таблице **auth** созданы следующие поля:

- passport_strategy - стратегия **passport.js**,
- passport_id - идентификатор, который мы получаем из сервиса.

В **passport.js** сервисы аутентификации называют стратегиями.

По-умолчанию настроена стратегия **google** по протоколу **OAuth 2.0**.

Каждая стратегия имеет свои особенности. Как правильно ее использовать, нужно читать в официальной документации по каждой стратегии.

Неизменным остается только принцип объявления стратегии:

```
@Injectable()
export class ... extends PassportStrategy(Strategy) {
  constructor(
    ...
  ) {
    super({
      ...
    });
  }

  async validate(...) {
    ...
    return ...;
  }
}
```

Вы экспортируете встраиваемый класс (декоратор **@Injectable()**), который расширяет базовый класс **PassportStrategy** с типом **Strategy**, полученным из нужной библиотеки. Например, из **passport-google-oauth20** или **passport-jwt**.

Также каждая стратегия имеет свое имя по-умолчанию (например, **jwt** для **passport-jwt**). Но вы можете задать свое имя:

```
export class ... extends PassportStrategy(Strategy, 'my_strategy_type') ...
```

Далее, в конструкторе, нужно обратиться к родителю через функцию **super()**, в которой передать объект с нужными для стратегии данными.

И последнее - нужно задать метод **validate**. В одном или нескольких аргументах он получает входящие данные. Например, для стратегии **passport-jwt** это объект данных, полученных из декодированного токена.

На выходе метод **validate** должен вернуть объект, доступный затем из поля **request.user** для следующих в очереди middleware. Из этого объекта вы сможете получить нужные вам данные пользователя.

> Стоит обратить внимание, что эти данные пользователя являются безопасными с точки зрения фреймворка и считаются актуальными, т.е. на момент аутентификации должны быть получены из базы данных.

Для того, чтобы стратегия заработала, нужно поместить ее в секцию **providers** модуля **auth.module**.

Подключаются стратегии в защитниках, например:

```
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class ... extends AuthGuard('my_strategy_type') {}
```

Здесь используется метод **AuthGuard** для работы с **passport.js**. Стратегия вызывается по имени, переданному в качестве аргумента. В данном случае **jwt**. Если вы задали стратегии свое имя, нужно прописать его.

[^ к оглавлению](#оглавление)

## Защитники

Защитники используются для ограничения доступа к таким ресурсам как контроллеры и резолверы.

```
  @Get('...')
  @UseGuards(...)
  async ...() {
    ...
  }
```

Защитники используют встроенный класс **AuthGuard**, который, в свою очередь, использует различные стратегии. Вы можете расширить его и переопределить его методы.

Например, можно задать цепочку стратегий:

```
export class ... extends AuthGuard(['my_strategy_1', 'my_strategy_2']) ...
```

Защитники выполняют только одну роль - авторизацию. Т.е. они определяют, пропустить или отклонить запрос.

```
import { ExecutionContext, Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class ... extends AuthGuard(...) {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    ...
  }
}
```

Отсюда видно, что метод **canActivate** получает контекст, т.е. все данные запроса, и возвращает true или false.

Вы можете переназначить родительские методы. Частая практика - переназначение **getRequest** для запросов **GraphQL**:

```
  getRequest(context: ExecutionContext) {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext().req;
  }
```

Вы также можете вызывать родительские методы, например **canActivate**:

```
return await super.canActivate(context);
```

Вы можете дополнять его своими методами и вызывать методы сторонних сервисов, таких как **authService**.

Добавлять защитников к запросу можно при помощи декоратора **@UseGuards(...)**. Но вы также можете создать свой декоратор, который будет вызывать защитников.

```
export const MyGuard = () => {
  return applyDecorators(UseGuards(MyGuard));
}
```

Использовать его будет намного проще:

```
  @Get('...')
  @MyGuard()
  async ...() {
    ...
  }
```

Также в декоратор вы можете добавить множество проверок и условий, последовательность вызова защитников, аргументы и пр.

[^ к оглавлению](#оглавление)

## Подключение сервиса google

Для авторизации/аутентификации через сервис google мы используем стратегию **GoogleStrategy** (с именем **google**) из библиотеки **passport-google-oauth20** и защитника **GoogleAuthGuard**.

Чтобы подключить сервис google, вам понадобится аккаунт разработчика. Получив его, перейдите в личный кабинет разработчика. Там вы должны будете создать новое веб-приложение, отвечающее за вход на сторонних для google ресурсах.

Вам нужно получить id клиента/приложения и ключ, который может называться token, secret или api key.

Вам также нужно указать страницу редиректа после успешного входа.

Мы вынесли эти данные в файл **.env**:

```
GOOGLE_CLIENT_ID=...
GOOGLE_CLIENT_SECRET=...
GOOGLE_CLIENT_CALLBACK=...
```

Пути мы задаем с помощью контроллера **auth**.

Мы используем следующий шаблон:

- /auth/google/login - для пути к форме входа,
- /auth/google/redirect - для пути редиректа.

Для ограничения доступа к этим путям, мы создаем защитника **GoogleAuthGuard**:

    /auth/guard/google.guard

И применяем его в контроллере:

```
  @Get('google/login')
  @UseGuards(GoogleAuthGuard)
  async googleLogin() {
    ...
  }

  @Get('google/redirect')
  @UseGuards(GoogleAuthGuard)
  async googleRedirect() {
    ...
  }
```

> По такому же принципу вы можете подключить любой похожий сервис. Мы выбрали сервис google для примера, потому, что он работает с приложением на локальной машине. Поэтому его удобно тестировать. Другие сервисы работают только с проектами, запущенными онлайн.

[^ к оглавлению](#оглавление)

# Токены

## Токен доступа

Токен доступа задается переменными окружения:

- **JWT_ACCESS_SECRET** - секретное слово для подписи токена,
- **JWT_ACCESS_EXPIRES** - время жизни токена.

> Время жизни токена по-сути определяет время простоя, в течение которого пользователя не выкинет из приложения, когда он не пользуется backend-ом.

> Время жизни токена работает только в том случае, если задана константа **JWT_EXPIRES**.

Мы рекомендуем сделать короткое время жизни токена - от нескольких секунд до нескольких минут.

Слишком маленькое время вызовет дополнительную нагрузку на сервер и клиент, т.к. будут часто выполнятся запросы на генерацию нового токена доступа.

Слишком большое время создаст риск безопасного использования. Например, если злоумышленник каким-то образом перехватит токен, он сможет пользоваться им в течение оставшегося времени.

На самом деле, время жизни токена доступа лучше назначать исходя из того, сколько времени может уйти на ряд стандартных операций, которые производит пользователь, заходя в ваше приложение.

Токен доступа отправляется клиенту в теле ответа, а затем принимается в заголовке **authorization** в виде **bearer token**.

На стороне клиента **access** токен можно хранить во временном хранилище, например в менеджере состояний.

[^ к оглавлению](#оглавление)

## Токен обновления

Для генерации токена обновления используются данные из переменных окружения:

- **JWT_REFRESH_SECRET** - задает секретное слово для подписи токена,
- **JWT_REFRESH_EXPIRES** - задает время жизни токена.

Токен обновления работает в точности так же, как и токен доступа.

По-умолчанию, время жизни устанавливается в 30 дней. Мы не рекомендуем делать время жизни токена слишком маленьким. Иначе пользователю придется часто выполнять вход.

Токен обновления не нужно передавать с каждым запросом, он не участвует ни в каких других процессах и нужен только для генерации токена доступа.

На стороне клиента **refresh** токен удобнее всего хранить в локальном хранилище, например в localStorage или sessionStorage.

[^ к оглавлению](#оглавление)

## Проверка токенов

Проверка **access** токена проходит средствами библиотеки **jwt**. По-сути мы проверяем только шифрованную подпись токена и время его действия.

Если проверка не пройдена, мы возвращаем ошибку.

Получив ее, клиент должен отправить запрос на обновление **access** токена. Для этого ему нужно предоставить **refresh** токен.

Токен **refresh** проходит ту же проверку, что и **access**. Но еще дополнительно проверяется его присутствие в данных сессии.

Если все хорошо, генерируется новая пара токенов, которые передаются клиенту обратно, как после авторизации. Новый **refresh** токен обновляется в сессионных данных.

Теперь клиент должен повторить запрос с новым **access** токеном.

Для закрытия сессии клиент должен очистить оба токена на своей стороне.

Мы также рекомендуем посылать запрос на закрытие сессии и очистку сессионных данных.

[^ к оглавлению](#оглавление)

# Сессии

Мы считаем сессией любой авторизованный вход в систему и дальнейшую работу с ней.

Сессия прекращается в тот момент, когда прекращается работа с системой. Это может происходить в трех случаях:

- истекает время действия токена,
- истекает время сессии,
- пользователь выходит из системы.

Сессионные данные хранятся на стороне сервера. В базе данных мы держим только историю подключений.

В сессионные данные записывается актуальный **refresh** токен. Благодаря этому, мы можем проверить подлинность токена и всей сессии.

Мы можем также открыть несколько сессий для одного пользователя с разных устройств.

Сессия не содержит никаких персональных данных. Хранить другую информацию небезопасно, но это и не требуется.

Также наличие сессии помогает убедиться, что запросы от пользователя не являются поддельными.

Сессии реализованы двумя механизмами:

- встроенный механизм сессий и сессионные данные,
- информация о подключениях пользователей в базе данных.

По-умолчанию сессионные данные хранятся в файлах в папке

    /sessions

[^ к оглавлению](#оглавление)

## Информация о сессии

Мы логируем в базу данных информацию о каждом подключении пользователя, когда происходит вход в систему и создается новая сессия.

Для этого мы выделили отдельную таблицу **sessions**.

Здесь хранится информация о подключении:

- время подключения (created_at),
- ip-адрес,
- агент пользователя (данные браузера),
- адрес ссылки (referrer).
- метод подключения (get/post).

Также cюда относятся локальные предпочтения пользователя, такие как код языковой страницы (ru, en и т.д.) и часовой пояс:

- locale (первый из заголовка accept-language),
- timezone (из заголовка timezone).

> Заголовок не стандартный, его передачу нужно написать вручную.

Привязка идет к авторизации/аутентификации, а не к пользователю и осуществляется по полю:

- auth_id.

Для истории сессий мы сделали отдельную сущность **sessions** со своими методами.

[^ к оглавлению](#оглавление)

## Проверка сессии

Проверка запросов целиком и полностью передана **access** токену.

Сессия является дополнительным механизмом, который помогает защитить **refresh** токен в случае его утечки.

Но вы можете расширить ответственность сессии. Например, благодаря связке authId, ip-адрес, userAgent и token, можно с определенной степенью достоверности валидировать пользователя и список разрешенных устройств, с которых он обычно входит в систему.

Теоретически, можно реализовать и классический механизм проверки сессии:

- генерация сессионного токена,
- передача клиенту,
- хранение токена в куки,
- передача токена от клиента на сервер в заголовке при каждом запросе,
- проверка сервером токена, полученного от клиента с токеном в сессионных данных.

Но мы не видим в этом смысла, т.к. механизм **jwt** токенов полностью заменяет этот механизм.

[^ к оглавлению](#оглавление)

# Сокеты

Сокеты реализованы в сущности **sockets**.

Для них есть все необходимые сервисы, контроллеры, резолверы.

Несколько пользователей, подключенные через сокеты, могут быть объединены в общую комнату.

[^ к оглавлению](#оглавление)

# Комнаты

Комнаты реализованы в сущности **rooms**.

Для них есть все необходимые сервисы, контроллеры, резолверы.

Комнаты объединяют подключения различных пользователей по сокетам.

[^ к оглавлению](#оглавление)

# Сервер авторизации

## Исходные данные для работы сервера авторизации

Есть пользователь, например, вы.

Есть агент или ваш веб-браузер.

Есть клиент или клиентское приложение, под которым вы работаете.

Есть сервер авторизации.

Есть стороннее приложение, к которому вы хотите получить доступ без ввода пароля. И потом это приложение сможет обмениваться данными с клиентским приложением.

Есть сторонний сервис авторизации, поддерживающий протокол OAuth 2.0, например, google или yandex, на котором также есть ваша учетная запись, через которую вы хотите зарегистрироваться на сервере авторизации и в клиентском приложении.

[^ к оглавлению](#оглавление)

## Процессы сервера авторизации

Идентификация - это проверка существования для вас пользовательского аккаунта в системе. Например, через id, логин или токена доступа.

Аутентификация - это проверка подлинности пользователя, что вы - это действительно этот пользователь, а не какой-то другой. Например, с помощью ввода пароля, пин-кода, использования биометрических данных или передачи токена доступа.

Авторизация - это выдача прав, доступных конкретному пользователю. Например, доступ к просмотру и отправке электронных писем, но отсутствие разрешения на создание новых почтовых ящиков.

Аутентификация невозможна без идентификации. А аутентификацию нельзя исключать из процесса по соображениям безопасности.

Тажке стоит понимать, что авторизация возможна без идентификации и аутентификации. Например, система может разрешить любому неопознанному пользователю доступ к просмотру документов. И несмотря на то, что пользователь может быть совершенно неопознанный и даже без аккаунта в системе, система все же его авторизовала - то есть выдала право прочитать этот документ.

[^ к оглавлению](#оглавление)

## Модуль клиента

Все описанные в этом разделе действия происходят от имени клиента. Соответственно, именно модуль клиента реализует авторизацию по протоколу OAuth 2.0. Простая авторизация пользователя на сервере работает и без этого модуля.

Весь модуль сделан согласно [спецификации RFC6749](https://datatracker.ietf.org/doc/html/rfc6749.html).

Данные клиента хранятся в таблице **clients**. В базовом варианте они содержат поля:

- id - порядковый индекс клиента в таблице,
- createdAt - дата создания записи,
- updatedAt - дата последнего изменения записи,
- client_id - идентификатор клиента, который назначается при создании клиента в формате uuid
- client_secret - секретный ключ клиента, назначается при создании в виде jwt токена, содержащего в себе client_id,
- client_password - пароль клиента, необязательное поле, при желании задается пользователем при регистрации клиента, как и пароль пользователя, хешируется
- client_type - один из разрешенных в спецификации OAuth 2.0 типов клиента,
- client_uri - хост клиента, с которого будут поступать запросы, нужен для реализации средств дополнительной безопасности,
- redirect_uri - адрес, на который будет обращаться клиент, например, лоя передачи токена после авторизации клиента или пользователя,
- title - заголовок клиента,
- description - описание клиента,
- publishedAt - дата, начиная с которой, клиент будет доступен для работы,
- isPublished - флаг доступности клиента, если он доступен по дате.

Также нужно понималь, что клиент должен быть связан с пользователем. Поэтому записи из таблицы **clients** будут иметь связи к записям из таблицы **auth**.

[^ к оглавлению](#оглавление)

# Правила именований

## Обычное именование

Для названия всех сущностей мы используем camelCase.

Например:

```
const myConst = ...
function myFunc(firstArgument, secondArgument)...
```

Да, обычно классы именуются с большой буквы. Но давайте будем честны, в большинстве случаев мы замыкаем классы и объекты в константы. К тому же в коде для нас нет большой разницы между методами, свойствами и ключами объекта.

[^ к оглавлению](#оглавление)

## Именование в базах данных

Для названия таблиц и полей в базе данных мы используем snake_case.

Например:

```
first_field
second_field
```

Однако при их переходе в код js, имена преобразуются в camelCase:

```
firstField
secondField
```

[^ к оглавлению](#оглавление)

## Именование сущностей булевого типа

Если переменные, константы или поля объекта являются булевым типом, а также если функции возвращают булев тип, то в начале их имени ставится **is**.

Например:

```
const isActivated = ...

if (isRegistered()) ...

class className {
  isNotEmpty: true
  ...
}
```

[^ к оглавлению](#оглавление)

## Именование действий

Иногда сущность является действием. Например это функция, метод или константа, которая служит псевдонимом для функции. В таком случае ее имя наверняка будет содержать глагол.

В этом случае глагол выносится вперед.

Например:

```
readUser
readUserLogin
```

[^ к оглавлению](#оглавление)

## Именование определений

Определение сущности, главное имя, всегда выносится вперед.

Например:

```
userLogin
userPassword
```

Как вы видели выше, обычно вперед выносится глагол. Но иногда вам может понадобится дать определение сущности.

Например, когда у вас есть несколько похожих функций для разных сущностей.

```
userReadId
userReadPassword
adminReadId
adminReadPassword
```

Однако появление таких имен сигнализирует о том, что с кодом что-то не так.

Например, можно использовать класс, чтобы стало хотя бы вот так:

```
user.readId
user.readPassword
admin.readId
admin.readPassword
```

А еще лучше - деструктуризацию, чтобы стало вот так:

```
{ userId, userPassword } = readUser
{ adminId, adminPassword } = readAdmin
```

[^ к оглавлению](#оглавление)

## Полное и краткое именование

Не старайтесь максимально сокращать и избегать более полного именования.

Сравните:

```
ult
# и
userLogoutAtTime
```

В то же время можно сокращать общепринятые термины и понятия, и избавляться от явных вещей.

Сравните:

```
const constantUserNumberAsInteger
funcGetUserInteger(value)
# и
const userNum
getUserInt(val)
```

## Именование файлов

Бывают случи, когда вы храните сущности в одной папке:

```
controllers
├── adminRead.js
├── adminWrite.js
├── adminCreate.js
├── adminDelete.js
├── userRead.js
├── userWrite.js
├── userCreate.js
└── userDelete.js
```

Здесь имеет смысл разделить их на две разные папки:

```
controllers
├── admin
│   └──...
└── user
    └──...
```

Но встает вопрос, менять ли теперь название сущностей?

На первый взгляд **user/read** смотрится лучше, чем **user/userRead**. Но что будет, если в одном коде встретятся разные сущности с одним и тем же названием?

```
import { read } from './controllers/user/read.js'
import { read } from './controllers/admin/read.js'
```

Можно использовать разное название через оператор **as** или через название самой сущности внутри файла.

```
import { read as readUser } from './controllers/user/read.js'
import { read as readAdmin } from './controllers/admin/read.js'
```

Можно сделать так:

```
export const readUser ...

...

export const readAdmin ...

...

import { readUser } from './controllers/user/readUser.js'
import { readAdmin } from './controllers/admin/readAdmin.js'
```

Но вообще появление такого кода сигнализирует о том, что с кодом что-то не так.

В этом случае, возможно, лучшим решением будет поменять всю структуру и использовать классы.

```
controllers
├── admin
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── user
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── admin.js
└── user.js
```

В файлах **admin.js** и **user.js** импортировать все сущности, а затем собрать их в классы и экспортировать.

```
import { read } from './admin/read.js'
...

export default class Admin {
  read: read,
  ...
}
```

```
import { read } from './user/read.js'
...

export default class User {
  read: read,
  ...
}
```

Теперь вы можете использовать их намного проще:

```
import userController from './controllers/user.js'
import adminController from './controllers/admin.js'

userController.read()
adminController.read()
```

[^ к оглавлению](#оглавление)

## Что дают правила именования

Следование этим правилом помогает читать код и интуитивно понимать, что перед вами, независимо от контекста.

Смотрите:

```
# булев тип
... isActivated ...

# константа или объект
... userLogin ...

# функция или метод
... readUser ...

# класс
... UserClassName ...
```

Мы инициализируем классы в константы с маленькой буквы.

Смотрите:

```
# импортируем класс
import SomeClass from './someClass'

# инициализируем класс
const someClass = new SomeClass()
```

В результате инициализированные классы у нас с маленькой буквы, и объекты у нас тоже с маленькой буквы. Но это нам ничуть не мешает. Потому что функцию или метод мы отличаем синтаксически.

Смотрите:

```
# константа
... someEntity ...

# ключ объекта или свойство класса
... someEntity.someName ...

# метод класса
... someEntity.someMethod() ...
```

[^ к оглавлению](#оглавление)
